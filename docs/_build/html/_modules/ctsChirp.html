
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>ctsChirp &#8212; ChiptuneSAK 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ctsChirp</h1><div class="highlight"><pre>
<span></span><span class="c1"># Midi Simple Processing Library</span>
<span class="c1">#</span>
<span class="c1"># 2019, David Knapp / David Youd</span>
<span class="c1">#</span>
<span class="c1"># Recommended Python version installed &gt;= 3.7.4</span>
<span class="c1"># Must first install midi: https://github.com/olemb/mido/blob/master/docs/installing.rst</span>
<span class="c1">#    pip install mido</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">more_itertools</span> <span class="k">as</span> <span class="nn">moreit</span>
<span class="kn">from</span> <span class="nn">ctsBase</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ctsConstants</span> <span class="kn">import</span> <span class="n">DEFAULT_MIDI_PPQN</span>


<div class="viewcode-block" id="Note"><a class="viewcode-back" href="../Classes.html#ctsChirp.Note">[docs]</a><span class="k">class</span> <span class="nc">Note</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a note in human-friendly form:  as a note with a start time, a duration, and</span>
<span class="sd">    a velocity. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tied_from</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tied_to</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">note</span>        <span class="c1">#: MIDI note number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">start</span>     <span class="c1">#: In ticks since tick 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>    <span class="c1">#: In ticks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">velocity</span>    <span class="c1">#: MIDI velocity 0-127</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied_from</span> <span class="o">=</span> <span class="n">tied_from</span>  <span class="c1">#: Is the next note tied from this note?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied_to</span> <span class="o">=</span> <span class="n">tied_to</span>      <span class="c1">#: Is this note ties from the previous note?</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Two notes are equal when their note numbers and durations are the same &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">note_num</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">note_num</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;pit=</span><span class="si">%3d</span><span class="s2">  st=</span><span class="si">%4d</span><span class="s2">  dur=</span><span class="si">%4d</span><span class="s2">  vel=</span><span class="si">%4d</span><span class="s2">, tfrom=</span><span class="si">%d</span><span class="s2"> tto=</span><span class="si">%d</span><span class="s2">&quot;</span> \
               <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">note_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied_to</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChirpTrack"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack">[docs]</a><span class="k">class</span> <span class="nc">ChirpTrack</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a track (or a voice) from a song.  It is basically a list of Notes with some</span>
<span class="sd">    other context information.</span>

<span class="sd">    ASSUMPTION: The track contains notes for only ONE instrument (midi channel).  Tracks with notes</span>
<span class="sd">    from more than one instrument will produce undefined results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the message types to preserve as a static variable</span>
    <span class="n">other_message_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pitchwheel&#39;</span><span class="p">,</span> <span class="s1">&#39;control_change&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chirp_song</span><span class="p">,</span> <span class="n">mchirp_track</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chirp_song</span> <span class="o">=</span> <span class="n">chirp_song</span>  <span class="c1">#: Parent song</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>  <span class="c1">#: Track name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#: This track&#39;s midi channel.  Each track should have notes from only one channel.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: The notes in the track</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: Program (patch) changes in the track</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: Other events in the track (includes voice changes and pitchwheel)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="n">chirp_song</span><span class="o">.</span><span class="n">qticks_notes</span>  <span class="c1">#: Inherit quantization from song</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="n">chirp_song</span><span class="o">.</span><span class="n">qticks_durations</span>  <span class="c1">#: Inherit quantization from song</span>
        <span class="k">if</span> <span class="n">mchirp_track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mchirp_track</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="s2">&quot;&lt;class &#39;ctsMChirp.MChirpTrack&#39;&gt;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChiptuneSAKTypeError</span><span class="p">(</span><span class="s2">&quot;ChirpTrack init can only import MChirpTrack objects&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">import_mchirp_track</span><span class="p">(</span><span class="n">mchirp_track</span><span class="p">)</span>

<div class="viewcode-block" id="ChirpTrack.import_mchirp_track"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.import_mchirp_track">[docs]</a>    <span class="k">def</span> <span class="nf">import_mchirp_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mchirp_track</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imports an  MChirpTrack</span>

<span class="sd">        :param mchirp_track:</span>
<span class="sd">        :type mchirp_track: MChirpTrack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_anneal_notes</span><span class="p">(</span><span class="n">notes</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function anneals, or combines, notes that crossed measure boundaries.  It&#39;s a local</span>
<span class="sd">            function that only exists here.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ret_val</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_note</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">notes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_note</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">current_note</span><span class="o">.</span><span class="n">tied_from</span><span class="p">,</span> <span class="s2">&quot;Continued note should be tied from: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">current_note</span>
                    <span class="k">assert</span> <span class="n">n</span><span class="o">.</span><span class="n">tied_to</span><span class="p">,</span> <span class="s2">&quot;Note should be tied to since last note was tied from: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span>
                    <span class="k">assert</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="n">current_note</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">current_note</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="s2">&quot;Tied notes not adjacent&quot;</span>
                    <span class="n">current_note</span><span class="o">.</span><span class="n">duration</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">tied_from</span><span class="p">:</span>
                        <span class="n">current_note</span><span class="o">.</span><span class="n">tied_from</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">tied_from</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ret_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_note</span><span class="p">)</span>
                        <span class="n">current_note</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">tied_from</span><span class="p">:</span>
                        <span class="n">current_note</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ret_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">current_note</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">ret_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">temp_notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Note</span><span class="p">)]</span>
        <span class="n">temp_triplets</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Triplet</span><span class="p">)]</span>
        <span class="n">temp_notes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">temp_triplets</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tp</span><span class="o">.</span><span class="n">content</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Note</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ProgramEvent</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mchirp_track</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">OtherMidiEvent</span><span class="p">)]</span>
        <span class="n">temp_notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">_anneal_notes</span><span class="p">(</span><span class="n">temp_notes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.estimate_quantization"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.estimate_quantization">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        This method estimates the optimal quantization for note starts and durations from the note</span>
<span class="sd">        data itself. This version only uses the current track for the optimization.  If the track</span>
<span class="sd">        is a part with long notes or not much movement, I recommend using the get_quantization()</span>
<span class="sd">        on the entire song instead. Many pieces have fairly well-defined note start spacing, but </span>
<span class="sd">        no discernable duration quantization, so in that case the default is half the note start </span>
<span class="sd">        quantization.  These values are easily overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmpNotes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="n">find_quantization</span><span class="p">(</span><span class="n">tmpNotes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chirp_song</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span><span class="p">)</span>
        <span class="n">tmpNotes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="n">find_duration_quantization</span><span class="p">(</span><span class="n">tmpNotes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.quantize"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.quantize">[docs]</a>    <span class="k">def</span> <span class="nf">quantize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qticks_notes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qticks_durations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method applies quantization to both note start times and note durations.  If you</span>
<span class="sd">        want either to remain unquantized, simply specify either qticks parameter to be 1, so</span>
<span class="sd">        that it will quantize to the nearest tick (i.e. leave everything unchanged)</span>

<span class="sd">        :param qticks_notes: Resolution of note starts in ticks</span>
<span class="sd">        :type qticks_notes: int</span>
<span class="sd">        :param qticks_durations: Resolution of note durations in ticks.  Also length of shortest note.</span>
<span class="sd">        :type qticks_durations: int</span>
<span class="sd">        :return: tuple of note start changes and note duration changes</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">note_start_changes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">duration_changes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Update the members to reflect the quantization applied</span>
        <span class="k">if</span> <span class="n">qticks_notes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="n">qticks_notes</span>
        <span class="k">if</span> <span class="n">qticks_durations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="n">qticks_durations</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="c1"># Store the &quot;before&quot; values for statistics</span>
            <span class="n">start_before</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span>
            <span class="n">duration_before</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span>
            <span class="c1"># Quantize the start times and durations</span>
            <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">quantize_fn</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">)</span>
            <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">quantize_fn</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span><span class="p">)</span>
            <span class="c1"># Never quantize a note duration to less than the minimum</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="c1"># Update the statistics</span>
            <span class="n">note_start_changes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">start_before</span><span class="p">)</span>
            <span class="n">duration_changes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">-</span> <span class="n">duration_before</span><span class="p">)</span>

        <span class="c1"># Quantize the other MIDI messages in the track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">quantize_fn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Return the statistics about changes</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">note_start_changes</span><span class="p">,</span> <span class="n">duration_changes</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.quantize_long"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.quantize_long">[docs]</a>    <span class="k">def</span> <span class="nf">quantize_long</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantizes only notes longer than 3/4 qticks; quantizes both start time and duration.  This function</span>
<span class="sd">        is useful for quantization that also preserves some ornaments, such as grace notes.</span>

<span class="sd">        :param qticks: Quantization for notes and durations</span>
<span class="sd">        :type qticks: int</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="n">qticks</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">quantize_fn</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">qticks</span><span class="p">)</span>
                <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">quantize_fn</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">qticks</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span></div>

<div class="viewcode-block" id="ChirpTrack.merge_notes"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.merge_notes">[docs]</a>    <span class="k">def</span> <span class="nf">merge_notes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_merge_length_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges immediately adjacent notes if they are short and have the same note number.</span>

<span class="sd">        :param max_merge_length_ticks: Length of the longest note to merge, in ticks</span>
<span class="sd">        :type max_merge_length_ticks: int</span>
<span class="sd">        :return: number of notes merged</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ret_notes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="n">last</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="n">duration</span> \
                    <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">note_num</span> <span class="o">==</span> <span class="n">last</span><span class="o">.</span><span class="n">note_num</span> \
                    <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;=</span> <span class="n">max_merge_length_ticks</span><span class="p">:</span>
                <span class="n">last</span><span class="o">.</span><span class="n">duration</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span>
                <span class="n">merged</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">ret_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">ret_notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">merged</span></div>

<div class="viewcode-block" id="ChirpTrack.remove_short_notes"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.remove_short_notes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_short_notes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_duration_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Removes notes shorter than max_duration_ticks from the track.</span>

<span class="sd">        :param max_duration_ticks: maximum duration of notes to remove, in ticks</span>
<span class="sd">        :type max_duration_ticks: int</span>
<span class="sd">        :return: Number of notes deleted</span>
<span class="sd">        :rtype: int</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ret_notes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;=</span> <span class="n">max_duration_ticks</span><span class="p">:</span>
                <span class="n">deleted</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">ret_notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">deleted</span></div>

<div class="viewcode-block" id="ChirpTrack.set_min_note_len"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.set_min_note_len">[docs]</a>    <span class="k">def</span> <span class="nf">set_min_note_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_len_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the minimum note length for the track.  Notes shorter than min_len_ticks will be lengthened</span>
<span class="sd">        and any notes that overlap will have their start times adjusted to allow the new longer note.</span>

<span class="sd">        :param min_len_ticks: Minimum note length</span>
<span class="sd">        :type min_len_ticks: int</span>
<span class="sd">        :return: tuple of (number of notes extended, number of notes with start adjusted)</span>
<span class="sd">        :rtype: tuple (int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>  <span class="c1"># Notes must be sorted</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="n">min_len_ticks</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">min_len_ticks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="n">last_end</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span>
                <span class="n">extended</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">last_end</span><span class="p">:</span>
                        <span class="n">tmp_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">last_end</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">tmp_end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
                        <span class="n">trimmed</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;=</span> <span class="n">min_len_ticks</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>  <span class="c1"># Notes must be sorted</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">extended</span><span class="p">,</span> <span class="n">trimmed</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.remove_polyphony"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.remove_polyphony">[docs]</a>    <span class="k">def</span> <span class="nf">remove_polyphony</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function eliminates polyphony, so that in each channel there is only one note</span>
<span class="sd">        active at a time. If a chord is struck all at the same time, it will retain the highest</span>
<span class="sd">        note.</span>

<span class="sd">        :return: (deleted, truncated)</span>
<span class="sd">        :rtype: (int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">truncated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ret_notes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">==</span> <span class="n">last</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
                <span class="n">deleted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">last</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="n">duration</span><span class="p">:</span>
                <span class="n">last</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">last</span><span class="o">.</span><span class="n">start_time</span>
                <span class="n">truncated</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">last</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">deleted</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">ret_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">ret_notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">deleted</span><span class="p">,</span> <span class="n">truncated</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.is_polyphonic"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.is_polyphonic">[docs]</a>    <span class="k">def</span> <span class="nf">is_polyphonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the track is polyphonic; if any notes overlap it is.</span>

<span class="sd">        :return: True if track is polyphonic.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">start_time</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">moreit</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">))</span></div>

<div class="viewcode-block" id="ChirpTrack.is_quantized"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.is_quantized">[docs]</a>    <span class="k">def</span> <span class="nf">is_quantized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the current track is quantized or not.  Since a quantization of 1 is equivalent to no</span>
<span class="sd">        quantization, a track quantized to tick will return False.</span>

<span class="sd">        :return: True if the track is quantized.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">==</span> <span class="mi">0</span>
                   <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">==</span> <span class="mi">0</span>
                   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpTrack.remove_keyswitches"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.remove_keyswitches">[docs]</a>    <span class="k">def</span> <span class="nf">remove_keyswitches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ks_max</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all MIDI notes with values less than or equal to ks_max. Some MIDI devices and applications use</span>
<span class="sd">        these extremely low notes to convey patch change or other information, so removing them (especially if</span>
<span class="sd">        you do not want polyphony) is a good idea.</span>

<span class="sd">        :param ks_max: maximum note number for keyswitches in the track (often 8)</span>
<span class="sd">        :type ks_max: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">note_num</span> <span class="o">&gt;</span> <span class="n">ks_max</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpTrack.truncate"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_tick</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate the track to max_tick</span>
<span class="sd">        :param max_tick:  maximum tick number for events to start (track will play to end of any notes started)</span>
<span class="sd">        :type max_tick: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpTrack.transpose"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">semitones</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transposes track in-place by semitones, which can be positive (transpose up) or negative (transpose down)</span>

<span class="sd">        :param semitones:  Number of semitones to transpose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="n">new_note_num</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">note_num</span> <span class="o">+</span> <span class="n">semitones</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_note_num</span> <span class="o">&lt;=</span> <span class="mi">127</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">new_note_num</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set duration to zero for later deletion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpTrack.modulate"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.modulate">[docs]</a>    <span class="k">def</span> <span class="nf">modulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modulates this track metrically by a factor of num / denom</span>

<span class="sd">        :param num:   Numerator of modulation</span>
<span class="sd">        :param denom: Denominator of modulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Change the start times of all the &quot;other&quot; events</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># Change all the note start times and durations</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span>
            <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span></div>

<div class="viewcode-block" id="ChirpTrack.scale_ticks"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.scale_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">scale_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales the ticks for this track by scale_factor.</span>

<span class="sd">        :param scale_factor:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Change all the note start times and durations</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="ChirpTrack.move_ticks"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpTrack.move_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">move_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves all the events in this track by offset_ticks.  Any events that would have a time in ticks less than 0 are</span>
<span class="sd">        set to time zero.</span>

<span class="sd">        :param offset_ticks:</span>
<span class="sd">        :type offset_ticks: int (signed)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Change all the note start times and durations</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">):</span>
            <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">set_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">program_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ProgramEvent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">program</span><span class="p">))]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="s2">&quot;Track: </span><span class="si">%s</span><span class="s2"> (channel </span><span class="si">%d</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret_val</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notes</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChirpSong"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong">[docs]</a><span class="k">class</span> <span class="nc">ChirpSong</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represents a song. It stores notes in an intermediate representation that</span>
<span class="sd">    approximates traditional music notation (as pitch-duration).  It also stores other</span>
<span class="sd">    information, such as time signatures and tempi, in a similar way.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mchirp_song</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">SongMetadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">=</span> <span class="n">DEFAULT_MIDI_PPQN</span>  <span class="c1">#: Pulses (ticks) per quarter note. Default is 960.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span>  <span class="c1">#: Quantization for note starts, in ticks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span>  <span class="c1">#: Quantization for note durations, in ticks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of ChirpTrack tracks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of all meta events that apply to the song as a whole</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midi_meta_tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of all the midi tracks that only contain metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midi_note_tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of all the tracks that contain notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of time signature changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of key signature changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of tempo changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#: Statistics about the song</span>
        <span class="k">if</span> <span class="n">mchirp_song</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mchirp_song</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="s2">&quot;&lt;class &#39;ctsMChirp.MChirpSong&#39;&gt;&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChiptuneSAKTypeError</span><span class="p">(</span><span class="s2">&quot;ChirpSong init can only import MChirpSong objects&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">import_mchirp_song</span><span class="p">(</span><span class="n">mchirp_song</span><span class="p">)</span>

<div class="viewcode-block" id="ChirpSong.reset_all"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.reset_all">[docs]</a>    <span class="k">def</span> <span class="nf">reset_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Clear all tracks and reinitialize to default values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">SongMetadata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">=</span> <span class="n">DEFAULT_MIDI_PPQN</span>  <span class="c1">#: Pulses (ticks) per quarter note.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span>  <span class="c1">#: Quantization for note starts, in ticks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span>  <span class="c1">#: Quantization for note durations, in ticks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of ChirpTrack tracks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of all meta events that apply to the song as a whole</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midi_meta_tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of all the midi tracks that only contain metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midi_note_tracks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of all the tracks that contain notes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of time signature changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of key signature changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of tempo changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#: Statistics about the song</span></div>

<div class="viewcode-block" id="ChirpSong.import_mchirp_song"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.import_mchirp_song">[docs]</a>    <span class="k">def</span> <span class="nf">import_mchirp_song</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mchirp_song</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imports an MChirpSong</span>

<span class="sd">        :param mchirp_song:</span>
<span class="sd">        :type mchirp_song: MChirpSong</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_all</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">mchirp_song</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ChirpTrack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mchirp_song</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="c1"># Now transfer over key signature, time signature, and tempo changes</span>
        <span class="c1"># these are stored inside measures for ALL tracks so we only have to extract them from one.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">mchirp_song</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">TimeSignatureEvent</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">KeySignatureEvent</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">measures</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">TempoEvent</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mchirp_song</span><span class="o">.</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.estimate_quantization"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.estimate_quantization">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        This method estimates the optimal quantization for note starts and durations from the note</span>
<span class="sd">        data itself. This version all note data in the tracks. Many pieces have no discernable </span>
<span class="sd">        duration quantization, so in that case the default is half the note start quantization.  </span>
<span class="sd">        These values are easily overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp_notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">notes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="n">find_quantization</span><span class="p">(</span><span class="n">tmp_notes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span><span class="p">)</span>
        <span class="n">tmp_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">notes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="n">find_duration_quantization</span><span class="p">(</span><span class="n">tmp_durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.quantize"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.quantize">[docs]</a>    <span class="k">def</span> <span class="nf">quantize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qticks_notes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qticks_durations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method applies quantization to both note start times and note durations.  If you</span>
<span class="sd">        want either to remain unquantized, simply specify a qticks parameter to be 1 (quantization</span>
<span class="sd">        of 1 tick).</span>

<span class="sd">        :param qticks_notes:     Quantization for note starts, in MIDI ticks</span>
<span class="sd">        :type qticks_notes: int</span>
<span class="sd">        :param qticks_durations: Quantization for note durations, in MIDI ticks</span>
<span class="sd">        :type qticks_durations: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Note Start Deltas&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Duration Deltas&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">qticks_notes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="n">qticks_notes</span>
        <span class="k">if</span> <span class="n">qticks_durations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="n">qticks_durations</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">note_start_changes</span><span class="p">,</span> <span class="n">duration_changes</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Note Start Deltas&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">note_start_changes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Duration Deltas&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">duration_changes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TempoEvent</span><span class="p">(</span><span class="n">quantize_fn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">qpm</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">TimeSignatureEvent</span><span class="p">(</span><span class="n">quantize_fn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">KeySignatureEvent</span><span class="p">(</span><span class="n">quantize_fn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">quantize_fn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.quantize_from_note_name"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.quantize_from_note_name">[docs]</a>    <span class="k">def</span> <span class="nf">quantize_from_note_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_note_duration_string</span><span class="p">,</span> <span class="n">dotted_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">triplets_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantize song with more user-friendly input than ticks.  Allowed quantizations are the keys for the</span>
<span class="sd">        ctsConstants.DURATION_STR dictionary.  If an input contains a &#39;.&#39; or a &#39;-3&#39; the corresponding</span>
<span class="sd">        values for dotted_allowed and triplets_allowed will be overridden.</span>

<span class="sd">        :param min_note_duration_string:  Quantization note value</span>
<span class="sd">        :type min_note_duration_string: str</span>
<span class="sd">        :param dotted_allowed:  If true, dotted notes are allowed</span>
<span class="sd">        :type dotted_allowed: bool</span>
<span class="sd">        :param triplets_allowed:  If true, triplets (of the specified quantization) are allowed</span>
<span class="sd">        :type triplets_allowed: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">min_note_duration_string</span><span class="p">:</span>
            <span class="n">dotted_allowed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">min_note_duration_string</span> <span class="o">=</span> <span class="n">min_note_duration_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;-3&#39;</span> <span class="ow">in</span> <span class="n">min_note_duration_string</span><span class="p">:</span>
            <span class="n">triplets_allowed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">min_note_duration_string</span> <span class="o">=</span> <span class="n">min_note_duration_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-3&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">qticks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">*</span> <span class="n">DURATION_STR</span><span class="p">[</span><span class="n">min_note_duration_string</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dotted_allowed</span><span class="p">:</span>
            <span class="n">qticks</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">triplets_allowed</span><span class="p">:</span>
            <span class="n">qticks</span> <span class="o">//=</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">qticks</span><span class="p">,</span> <span class="n">qticks</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.is_quantized"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.is_quantized">[docs]</a>    <span class="k">def</span> <span class="nf">is_quantized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Has the song been quantized?  This requires that all the tracks have been quantized with their</span>
<span class="sd">        current qticks_notes and qticks_durations values.</span>

<span class="sd">        :return:  Boolean True if all tracks in the song are quantized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_quantized</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.explode_polyphony"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.explode_polyphony">[docs]</a>    <span class="k">def</span> <span class="nf">explode_polyphony</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_track</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;Explodes&#39; a single track into multi-track polyphony.  The new tracks replace the old track in the</span>
<span class="sd">        song&#39;s list of tracks, so later tracks may be pushed to higher indexes.</span>

<span class="sd">        :param i_track:  index of the track for the song</span>
<span class="sd">        :type i_track: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_get_available_tracks</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">current_notes</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_notes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">note</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
            <span class="c1">#ret.sort(key=lambda n: (-current_notes[n].note_num))</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="n">old_track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i_track</span><span class="p">)</span>
        <span class="n">old_track</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="n">note_num</span><span class="p">))</span>
        <span class="n">new_tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ChirpTrack</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="n">current_notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Note</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">note</span> <span class="ow">in</span> <span class="n">old_track</span><span class="o">.</span><span class="n">notes</span><span class="p">:</span>
            <span class="n">possible</span> <span class="o">=</span> <span class="n">_get_available_tracks</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">current_notes</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ChirpTrack</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">new_tracks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
                <span class="n">current_notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">possible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_tracks</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">notes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
                <span class="n">current_notes</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">note</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_tracks</span><span class="p">):</span>
            <span class="n">new_tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">old_track</span><span class="o">.</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">old_track</span><span class="o">.</span><span class="n">channel</span>
            <span class="n">new_tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">old_track</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; s</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">new_tracks</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i_track</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.remove_polyphony"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.remove_polyphony">[docs]</a>    <span class="k">def</span> <span class="nf">remove_polyphony</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate polyphony from all tracks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Truncated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Deleted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">deleted</span><span class="p">,</span> <span class="n">truncated</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">remove_polyphony</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Truncated&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">truncated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Deleted&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">deleted</span></div>

<div class="viewcode-block" id="ChirpSong.is_polyphonic"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.is_polyphonic">[docs]</a>    <span class="k">def</span> <span class="nf">is_polyphonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the song polyphonic?  Returns true if ANY of the tracks contains polyphony of any kind.</span>

<span class="sd">        :return: Boolean True if any track in the song is polyphonic</span>
<span class="sd">        :rtype: boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_polyphonic</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.remove_keyswitches"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.remove_keyswitches">[docs]</a>    <span class="k">def</span> <span class="nf">remove_keyswitches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ks_max</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some MIDI programs use extremely low notes as a signaling mechanism.</span>
<span class="sd">        This method removes notes with pitch &lt;= ks_max from all tracks.</span>

<span class="sd">        :param ks_max:  Maximum note number for the control notes</span>
<span class="sd">        :type ks_max: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">remove_keyswitches</span><span class="p">(</span><span class="n">ks_max</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.truncate"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_tick</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncate the song to max_tick</span>
<span class="sd">        :param max_tick:  maximum tick number for events to start (song will play to end of any notes started)</span>
<span class="sd">        :type max_tick: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ks</span> <span class="k">for</span> <span class="n">ks</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="k">if</span> <span class="n">ks</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;=</span> <span class="n">max_tick</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">max_tick</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChirpSong.transpose"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">semitones</span><span class="p">,</span> <span class="n">minimize_accidentals</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transposes the song by semitones</span>
<span class="sd">        :param semitones:  number of semitones to transpose by.  Positive transposes to higher pitch.</span>
<span class="sd">        :type semitones: int</span>
<span class="sd">        :param minimize_accidentals: True to choose key signature to minimize number of accidentals</span>
<span class="sd">        :type minimize_accidentals: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, transpose key signatures</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ks</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">):</span>
            <span class="n">new_key</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">semitones</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">minimize_accidentals</span><span class="p">:</span>
                <span class="n">new_key</span><span class="o">.</span><span class="n">minimize_accidentals</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">KeySignatureEvent</span><span class="p">(</span><span class="n">ks</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">new_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">key_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Now transpose the tracks</span>
        <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">semitones</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.modulate"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.modulate">[docs]</a>    <span class="k">def</span> <span class="nf">modulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs metric modulation.  It does so by multiplying the length of all notes by num/denom,</span>
<span class="sd">        and also automatically adjusts the time signatures and tempos such that the resulting music will sound</span>
<span class="sd">        identical to the original.</span>

<span class="sd">        :param num:    Numerator of metric modulation</span>
<span class="sd">        :type num: int</span>
<span class="sd">        :param denom:  Denominator of metric modulation</span>
<span class="sd">        :type denom: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First adjust the time signatures</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">):</span>
            <span class="c1"># The time signature always has to be whole numbers so if the new numerator is not an integer fix that</span>
            <span class="c1">#  by multiplying by 3/2</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ts</span>
            <span class="n">new_time_signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">num</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">denom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">denom</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">v</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_time_signature</span><span class="p">):</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">new_time_signature</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">4</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">v</span> <span class="o">%</span> <span class="n">factor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_time_signature</span><span class="p">):</span>
                        <span class="n">new_time_signature</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">//</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_time_signature</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSignatureEvent</span><span class="p">((</span><span class="n">t</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span><span class="p">,</span> <span class="o">*</span><span class="n">new_time_signature</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">time_signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Now the key signatures</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ks</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">):</span>
            <span class="c1"># The time signature always has to be whole numbers so if the new numerator is not an integer fix that</span>
            <span class="c1">#  by multiplying by 3/2</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">KeySignatureEvent</span><span class="p">((</span><span class="n">t</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1"># Next the tempos</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">):</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">qpm</span> <span class="o">=</span> <span class="n">tm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TempoEvent</span><span class="p">((</span><span class="n">t</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span><span class="p">,</span> <span class="p">(</span><span class="n">qpm</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span><span class="p">)</span>
        <span class="c1"># Now all the rest of the meta messages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">((</span><span class="n">t</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># Finally, modulate each track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">modulate</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
        <span class="c1"># Now adjust the quantizations in case quantization has been applied to reflect the new lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">*</span> <span class="n">num</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span></div>

<div class="viewcode-block" id="ChirpSong.scale_ticks"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.scale_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">scale_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales the ticks for all events in the song.  Multiplies the time for each event by scale_factor.</span>
<span class="sd">        This method also changes the ppq by the scale factor.</span>

<span class="sd">        :param scale_factor: Floating-point scale factor to multiply all events.</span>
<span class="sd">        :type scale_factor: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># First adjust the time signatures</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">):</span>
            <span class="c1"># The time signature always has to be whole numbers so if the new numerator is not an integer fix that</span>
            <span class="c1">#  by multiplying by 3/2</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSignatureEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
        <span class="c1"># Now the key signature changes</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ks</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ks</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">KeySignatureEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># Next the tempos</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TempoEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">qpm</span><span class="p">)</span>
        <span class="c1"># Now all the rest of the meta messages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Now adjust the quantizations in case quantization has been applied to reflect the new lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_notes</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qticks_durations</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Finally, scale each track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale_ticks</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.move_ticks"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.move_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">move_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves all notes in the song a given number of ticks.  Adds the offset to the current tick for every event.</span>
<span class="sd">        If the resulting event has a negative starting time in ticks, it is set to 0.</span>

<span class="sd">        :param offset_ticks:  Offset in ticks</span>
<span class="sd">        :type offset_ticks: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First adjust the time signatures</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">):</span>
            <span class="c1"># The time signature always has to be whole numbers so if the new numerator is not an integer fix that</span>
            <span class="c1">#  by multiplying by 3/2</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSignatureEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
        <span class="c1"># Now the key signature changes</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ks</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ks</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">KeySignatureEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># Next the tempos</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TempoEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">qpm</span><span class="p">)</span>
        <span class="c1"># Now all the rest of the meta messages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">offset_ticks</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">OtherMidiEvent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Finally, offset each track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">move_ticks</span><span class="p">(</span><span class="n">offset_ticks</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.set_qpm"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.set_qpm">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the tempo in BPM for the entire song.  Any existing tempo events will be removed.</span>
<span class="sd">        :param qpm: quarter-notes per minute tempo</span>
<span class="sd">        :type qpm: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">qpm</span> <span class="o">=</span> <span class="n">qpm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tempo_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">TempoEvent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">qpm</span><span class="p">)]</span></div>

<div class="viewcode-block" id="ChirpSong.set_time_signature"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.set_time_signature">[docs]</a>    <span class="k">def</span> <span class="nf">set_time_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the time signature for the entire song.  Any existing time signature changes will be removed.</span>

<span class="sd">        :param num:</span>
<span class="sd">        :type num:</span>
<span class="sd">        :param denom:</span>
<span class="sd">        :type num:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">TimeSignatureEvent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">)]</span></div>

<div class="viewcode-block" id="ChirpSong.set_key_signature"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.set_key_signature">[docs]</a>    <span class="k">def</span> <span class="nf">set_key_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the key signature for the entire song.  Any existing key signatures and changes will be removed.</span>

<span class="sd">        :param new_key: Key signature.  String such as &#39;A#&#39; or &#39;Abm&#39;</span>
<span class="sd">        :type new_key: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span> <span class="o">=</span> <span class="p">[</span><span class="n">KeySignatureEvent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ChirpKey</span><span class="p">(</span><span class="n">new_key</span><span class="p">))]</span></div>

<div class="viewcode-block" id="ChirpSong.end_time"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.end_time">[docs]</a>    <span class="k">def</span> <span class="nf">end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the end time of the last note in the song.</span>

<span class="sd">        :return: Time (in ticks) of the end of the last note in the song.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracks</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">notes</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChirpSong.measure_starts"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.measure_starts">[docs]</a>    <span class="k">def</span> <span class="nf">measure_starts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the starting time for measures in the song.  Calculated using time_signature_changes.</span>

<span class="sd">        :return: List of measure starting times in MIDI ticks</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measures_and_beats</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">beat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpSong.measures_and_beats"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.measures_and_beats">[docs]</a>    <span class="k">def</span> <span class="nf">measures_and_beats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the positions of all measures and beats in the song.  Calculated using time_signature_changes.</span>

<span class="sd">        :return: List of MeasureBeat objects for each beat of the song.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">measures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>
        <span class="n">time_signature_changes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_signature_changes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">time_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="s2">&quot;No starting time signature&quot;</span><span class="p">)</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">time_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">time_signature_changes</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
                <span class="n">measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Beat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">//</span> <span class="n">last</span><span class="o">.</span><span class="n">denom</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">last</span><span class="o">.</span><span class="n">num</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">max_time</span><span class="p">:</span>
            <span class="n">measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Beat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">ppq</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">//</span> <span class="n">last</span><span class="o">.</span><span class="n">denom</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">last</span><span class="o">.</span><span class="n">num</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;Measures&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">measures</span></div>

<div class="viewcode-block" id="ChirpSong.get_measure_beat"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.get_measure_beat">[docs]</a>    <span class="k">def</span> <span class="nf">get_measure_beat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_in_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a (measure, beat) tuple for a given time; the time is greater than or</span>
<span class="sd">        equal to the returned measure and beat but less than the next.  The result should be</span>
<span class="sd">        interpreted as the time being during the measure and beat returned.</span>

<span class="sd">        :param time_in_ticks:  Time during the song, in MIDI ticks</span>
<span class="sd">        :type time_in_ticks: int</span>
<span class="sd">        :return:  MeasureBeat object with the current measure and beat</span>
<span class="sd">        :rtype: MeasureBeat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">measure_beats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measures_and_beats</span><span class="p">()</span>
        <span class="c1"># Make a list of start times from the list of measure-beat times.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start_time</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">measure_beats</span><span class="p">]</span>
        <span class="c1"># Find the index of the desired time in the list.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">time_in_ticks</span><span class="p">)</span>
        <span class="c1"># Return the corresponding measure/beat</span>
        <span class="k">return</span> <span class="n">measure_beats</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpSong.get_active_time_signature"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.get_active_time_signature">[docs]</a>    <span class="k">def</span> <span class="nf">get_active_time_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_in_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the active time signature at a given time (in ticks) during the song.</span>

<span class="sd">        :param time_in_ticks:  Time during the song, in MIDI ticks</span>
<span class="sd">        :type time_in_ticks: int</span>
<span class="sd">        :return: Active time signature at the time</span>
<span class="sd">        :rtype: TimeSignatureChange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">itime</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="s2">&quot;No starting time signature&quot;</span><span class="p">)</span>
        <span class="n">n_time_signature_changes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">itime</span> <span class="o">&lt;</span> <span class="n">n_time_signature_changes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">itime</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">time_in_ticks</span><span class="p">:</span>
            <span class="n">itime</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_signature_changes</span><span class="p">[</span><span class="n">itime</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="ChirpSong.get_active_key_signature"><a class="viewcode-back" href="../Classes.html#ctsChirp.ChirpSong.get_active_key_signature">[docs]</a>    <span class="k">def</span> <span class="nf">get_active_key_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_in_ticks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the active key signature at a given time (in ticks) during the song.</span>

<span class="sd">        :param time_in_ticks: Time during the song, in MIDI ticks</span>
<span class="sd">        :type time_in_ticks: int</span>
<span class="sd">        :return: Key signature active at the time</span>
<span class="sd">        :rtype: KeySignatureChange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ikey</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="s2">&quot;No starting time signature&quot;</span><span class="p">)</span>
        <span class="n">n_key_signature_changes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">ikey</span> <span class="o">&lt;</span> <span class="n">n_key_signature_changes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">time_in_ticks</span><span class="p">:</span>
            <span class="n">ikey</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_signature_changes</span><span class="p">[</span><span class="n">ikey</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ChiptuneSAK</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MusicConcepts.html">Musical Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html">Chirp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html#chirp-formats">Chirp Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html#concepts-in-chirp-music-representation">Concepts in chirp music representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sheetmusic.html">PDF Sheetmusic via Lilypond</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c128BASIC.html">C128 BASIC music programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Classes.html">Classes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, David Youd and David Knapp.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>