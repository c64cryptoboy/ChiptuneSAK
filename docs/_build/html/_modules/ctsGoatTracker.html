
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>ctsGoatTracker &#8212; ChiptuneSAK 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ctsGoatTracker</h1><div class="highlight"><pre>
<span></span><span class="c1"># Code to import and export goattracker .sng files (both regular and stereo)</span>
<span class="c1"># </span>
<span class="c1"># Notes:</span>
<span class="c1"># - This code ignores multispeed (for now)</span>
<span class="c1">#</span>
<span class="c1"># FUTUREs:</span>
<span class="c1"># - Add instrument file loader to use with channels on exports</span>

<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">ctsConstants</span> <span class="kn">import</span> <span class="n">ARCH</span><span class="p">,</span> <span class="n">C0_MIDI_NUM</span>
<span class="kn">import</span> <span class="nn">ctsChirp</span>
<span class="kn">import</span> <span class="nn">ctsRChirp</span>
<span class="kn">import</span> <span class="nn">ctsMidi</span>
<span class="kn">from</span> <span class="nn">ctsErrors</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Generalized instrument handling when creating new goattracker binaries is not supported yet.</span>
<span class="c1"># So this constant is used so it&#39;s easy to look through the code to see where hardcoded assumptions</span>
<span class="c1"># are being made.</span>
<span class="n">DEFAULT_INSTRUMENT</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># GoatTracker constants</span>
<span class="n">GT_FILE_HEADER</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;GTS5&#39;</span>
<span class="n">GT_DEFAULT_TEMPO</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">GT_DEFAULT_FUNKTEMPOS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>  <span class="c1"># default alternating tempos, from gplay.c</span>

<span class="c1"># All these MAXes are the same for goattracker 2 (1SID) and goattracker 2 stereo (2SID)</span>
<span class="c1"># (Note: MAXes vary in the SID-Wizard 1SID, 2SID, and 3SID engines)</span>
<span class="c1"># Most found in gcommon.h</span>
<span class="n">GT_MAX_SUBTUNES_PER_SONG</span> <span class="o">=</span> <span class="mi">32</span>  <span class="c1"># Each subtune gets its own orderlist of patterns</span>
<span class="c1"># &quot;song&quot; means a collection of independently-playable subtunes</span>
<span class="n">GT_MAX_ELM_PER_ORDERLIST</span> <span class="o">=</span> <span class="mi">255</span>  <span class="c1"># at minimum, it must contain the endmark and following byte</span>
<span class="n">GT_MAX_INSTR_PER_SONG</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">63</span>
<span class="n">GT_MAX_PATTERNS_PER_SONG</span> <span class="o">=</span> <span class="mi">208</span>  <span class="c1"># patterns can be shared across channels and subtunes</span>
<span class="n">GT_MAX_ROWS_PER_PATTERN</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># and min rows (not including end marker) is 1  ! Does 128 include end marker?</span>
<span class="n">GT_MAX_TABLE_LEN</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">GT_REST</span> <span class="o">=</span> <span class="mh">0xBD</span>  <span class="c1"># A rest in goattracker means NOP, not rest</span>
<span class="n">GT_NOTE_OFFSET</span> <span class="o">=</span> <span class="mh">0x60</span>  <span class="c1"># Note value offset</span>
<span class="n">GT_MAX_NOTE_VALUE</span> <span class="o">=</span> <span class="mh">0xBF</span>  <span class="c1"># Maximum possible value for note</span>
<span class="n">GT_KEY_OFF</span> <span class="o">=</span> <span class="mh">0xBE</span>
<span class="n">GT_KEY_ON</span> <span class="o">=</span> <span class="mh">0xBF</span>
<span class="n">GT_OL_RST</span> <span class="o">=</span> <span class="mh">0xFF</span>  <span class="c1"># order list restart marker</span>
<span class="n">GT_PAT_END</span> <span class="o">=</span> <span class="mh">0xFF</span>  <span class="c1"># pattern end</span>
<span class="n">GT_TEMPO_CHNG_CMD</span> <span class="o">=</span> <span class="mh">0x0F</span>


<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Code to parse goattracker and goattracker stereo files</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">GtHeader</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">song_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">author_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">copyright</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">num_subtunes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">GtPatternRow</span><span class="p">:</span>
    <span class="n">note_data</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">GT_REST</span>
    <span class="n">instr_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">command</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">command_data</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a pattern row into GT bytes.</span>
<span class="sd">        :return: bytes that represet the pattern row</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">note_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">GT_NOTE_OFFSET</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">note_data</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_NOTE_VALUE</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">note_data</span> <span class="o">!=</span> <span class="n">GT_PAT_END</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Illegal GT note value number: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">note_data</span><span class="si">:</span><span class="s1">02X</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">note_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">note_data</span> <span class="o">=</span> <span class="n">GT_REST</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">instr_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;None instrument number&quot;</span>
            <span class="k">return</span> <span class="nb">bytes</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">note_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instr_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">command</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_data</span><span class="p">])</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">GtInstrument</span><span class="p">:</span>
    <span class="n">instr_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">attack_decay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sustain_release</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wave_ptr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pulse_ptr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">filter_ptr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vib_speedtable_ptr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vib_delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gateoff_timer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mh">0x02</span>
    <span class="n">hard_restart_1st_frame_wave</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mh">0x09</span>
    <span class="n">inst_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">GtTable</span><span class="p">:</span>
    <span class="n">row_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">left_col</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">right_col</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>


<div class="viewcode-block" id="GTSong"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.GTSong">[docs]</a><span class="k">class</span> <span class="nc">GTSong</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains parsed .sng data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers</span> <span class="o">=</span> <span class="n">GtHeader</span><span class="p">()</span>  <span class="c1">#: goattracker file headers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">#: 3 or 6 voices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtune_orderlists</span> <span class="o">=</span> <span class="p">[[[],</span> <span class="p">[],</span> <span class="p">[]]]</span>  <span class="c1">#: Nested lists: Subtunes-&gt;channels-&gt;orderlist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instruments</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of GtInstrument instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave_table</span> <span class="o">=</span> <span class="n">GtTable</span><span class="p">()</span>  <span class="c1">#: wave table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_table</span> <span class="o">=</span> <span class="n">GtTable</span><span class="p">()</span>  <span class="c1">#: pulse table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_table</span> <span class="o">=</span> <span class="n">GtTable</span><span class="p">()</span>  <span class="c1">#: filter table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed_table</span> <span class="o">=</span> <span class="n">GtTable</span><span class="p">()</span>  <span class="c1">#: speed table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span> <span class="o">=</span> <span class="p">[[]]</span>  <span class="c1">#: Nested lists: patterns-&gt;GtPatternRow instances</span>

<div class="viewcode-block" id="GTSong.is_stereo"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.GTSong.is_stereo">[docs]</a>    <span class="k">def</span> <span class="nf">is_stereo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if this is stereo GoatTracker</span>
<span class="sd">        </span>
<span class="sd">        :return: True if stereo, False if not</span>
<span class="sd">        :rtype: boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">&gt;=</span> <span class="mi">4</span></div></div>


<span class="k">def</span> <span class="nf">pattern_note_to_midi_note</span><span class="p">(</span><span class="n">pattern_note_byte</span><span class="p">,</span> <span class="n">octave_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert pattern note byte value into midi note value</span>

<span class="sd">    :param pattern_note_byte:  GT note value</span>
<span class="sd">    :type pattern_note_byte: int</span>
<span class="sd">    :param octave_offset: Should always be zero unless some weird midi offset exists</span>
<span class="sd">    :type octave_offset: int</span>
<span class="sd">    :return: Midi note number</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">midi_note</span> <span class="o">=</span> <span class="n">pattern_note_byte</span> <span class="o">-</span> <span class="p">(</span><span class="n">GT_NOTE_OFFSET</span> <span class="o">-</span> <span class="n">C0_MIDI_NUM</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">octave_offset</span> <span class="o">*</span> <span class="mi">12</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">midi_note</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: illegal midi note value </span><span class="si">{</span><span class="n">midi_note</span><span class="si">}</span><span class="s2"> from gt </span><span class="si">{</span><span class="n">pattern_note_byte</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">midi_note</span>


<span class="k">def</span> <span class="nf">midi_note_to_pattern_note</span><span class="p">(</span><span class="n">midi_note</span><span class="p">,</span> <span class="n">octave_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert midi note value to pattern note value</span>

<span class="sd">    :param midi_note: midi note number (NOTE: Lowest midi note allowed = 12 (C0_MIDI_NUM)</span>
<span class="sd">    :type midi_note: int</span>
<span class="sd">    :param octave_offset: Should always be zero unless some weird midi offset exists</span>
<span class="sd">    :type octave_offset: int</span>
<span class="sd">    :return: GT note value</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gt_note_value</span> <span class="o">=</span> <span class="n">midi_note</span> <span class="o">+</span> <span class="p">(</span><span class="n">GT_NOTE_OFFSET</span> <span class="o">-</span> <span class="n">C0_MIDI_NUM</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">octave_offset</span> <span class="o">*</span> <span class="mi">12</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">GT_NOTE_OFFSET</span> <span class="o">&lt;=</span> <span class="n">gt_note_value</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_NOTE_VALUE</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: illegal gt note data value </span><span class="si">{</span><span class="n">gt_note_value</span><span class="si">}</span><span class="s2"> from midi </span><span class="si">{</span><span class="n">midi_note</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gt_note_value</span>


<span class="k">def</span> <span class="nf">get_chars</span><span class="p">(</span><span class="n">in_bytes</span><span class="p">,</span> <span class="n">trim_nulls</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">in_bytes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;Latin-1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trim_nulls</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># no interpretation, preserve encoding</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">get_orderlist</span><span class="p">(</span><span class="n">an_index</span><span class="p">,</span> <span class="n">file_bytes</span><span class="p">):</span>
    <span class="c1"># Note: orderlist length byte is length -1</span>
    <span class="c1">#    e.g. orderlist CHN1: &quot;00 04 07 0d 09 RST00&quot; in file as 06 00 04 07 0d 09 FF 00</span>
    <span class="c1">#    length-1 (06), followed by 7 bytes</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># add one for restart</span>
    <span class="n">an_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">orderlist</span> <span class="o">=</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span><span class="p">:</span><span class="n">an_index</span> <span class="o">+</span> <span class="n">length</span><span class="p">]</span>
    <span class="n">an_index</span> <span class="o">+=</span> <span class="n">length</span>
    <span class="c1"># check that next-to-last byte is $FF</span>
    <span class="k">assert</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span><span class="p">,</span> <span class="s2">&quot;Error: Did not find expected $FF RST endmark in channel&#39;s orderlist&quot;</span>

    <span class="k">return</span> <span class="n">orderlist</span>


<span class="c1"># Parse the wave, pulse, filter, or speed table</span>
<span class="k">def</span> <span class="nf">get_table</span><span class="p">(</span><span class="n">an_index</span><span class="p">,</span> <span class="n">file_bytes</span><span class="p">):</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span><span class="p">]</span>
    <span class="c1"># no point in checking rows &gt; GT_MAX_TABLE_LEN, since GT_MAX_TABLE_LEN is a $FF (max byte val)</span>
    <span class="n">an_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">left_entries</span> <span class="o">=</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span><span class="p">:</span><span class="n">an_index</span> <span class="o">+</span> <span class="n">rows</span><span class="p">]</span>
    <span class="n">an_index</span> <span class="o">+=</span> <span class="n">rows</span>

    <span class="n">right_entries</span> <span class="o">=</span> <span class="n">file_bytes</span><span class="p">[</span><span class="n">an_index</span><span class="p">:</span><span class="n">an_index</span> <span class="o">+</span> <span class="n">rows</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">GtTable</span><span class="p">(</span><span class="n">row_cnt</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">left_col</span><span class="o">=</span><span class="n">left_entries</span><span class="p">,</span> <span class="n">right_col</span><span class="o">=</span><span class="n">right_entries</span><span class="p">)</span>


<span class="c1"># If a 3-channel orderlist is found, returns the byte after the end, else return -1</span>
<span class="k">def</span> <span class="nf">has_3_channel_orderlist</span><span class="p">(</span><span class="n">file_index</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">index_of_ff</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="n">index_of_ff</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">file_index</span> <span class="o">+=</span> <span class="n">index_of_ff</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">file_index</span>


<span class="c1"># Returns true if a 6-channel orderlist is found, evidence that this is a goattracker stereo sng file</span>
<span class="k">def</span> <span class="nf">is_2sid</span><span class="p">(</span><span class="n">index_at_start_of_orderlist</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">):</span>
    <span class="n">file_index</span> <span class="o">=</span> <span class="n">has_3_channel_orderlist</span><span class="p">(</span><span class="n">index_at_start_of_orderlist</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">file_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: could not parse orderlist&quot;</span>
    <span class="k">return</span> <span class="n">has_3_channel_orderlist</span><span class="p">(</span><span class="n">file_index</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>


<div class="viewcode-block" id="import_sng_file_to_rchirp"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.import_sng_file_to_rchirp">[docs]</a><span class="k">def</span> <span class="nf">import_sng_file_to_rchirp</span><span class="p">(</span><span class="n">input_filename</span><span class="p">,</span> <span class="n">subtune_number</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a GoatTracker sng file (normal or stereo) into an RChirp song instance</span>

<span class="sd">    :param input_filename: sng input path and filename</span>
<span class="sd">    :type input_filename: str</span>
<span class="sd">    :param subtune_number: the subtune number, defaults to 0</span>
<span class="sd">    :type subtune_number: int, optional</span>
<span class="sd">    :return: An RChirp song for the subtune</span>
<span class="sd">    :rtype: RChirpSong</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">input_filename</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.sng&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKIOError</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Error: Expecting input filename that ends in &quot;.sng&quot;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">input_filename</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKIOError</span><span class="p">(</span><span class="s1">&#39;Cannot find &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">input_filename</span><span class="p">)</span>

    <span class="n">sng_data</span> <span class="o">=</span> <span class="n">import_sng_file_to_parsed_gt</span><span class="p">(</span><span class="n">input_filename</span><span class="p">)</span>
    <span class="n">max_subtune_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sng_data</span><span class="o">.</span><span class="n">subtune_orderlists</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">subtune_number</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="s1">&#39;subtune_number must be &gt;= 0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subtune_number</span> <span class="o">&gt;</span> <span class="n">max_subtune_number</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKValueError</span><span class="p">(</span><span class="s1">&#39;subtune_number must be &lt;= </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">max_subtune_number</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">import_parsed_gt_to_rchirp</span><span class="p">(</span><span class="n">sng_data</span><span class="p">,</span> <span class="n">subtune_number</span><span class="p">)</span></div>


<div class="viewcode-block" id="import_sng_file_to_parsed_gt"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.import_sng_file_to_parsed_gt">[docs]</a><span class="k">def</span> <span class="nf">import_sng_file_to_parsed_gt</span><span class="p">(</span><span class="n">input_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a goat tracker &#39;.sng&#39; file and put it into a GTSong instance.</span>
<span class="sd">    Supports 1SID and 2SID (stereo) goattracker &#39;.sng&#39; files.</span>
<span class="sd">    </span>
<span class="sd">    :param input_filename: Filename for input .sng file</span>
<span class="sd">    :type input_filename: string</span>
<span class="sd">    :return: A GTSong instance holding the parsed goattracker file</span>
<span class="sd">    :rtype: GTSong</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">input_filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sng_bytes</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">import_sng_binary_to_parsed_gt</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">)</span></div>


<div class="viewcode-block" id="import_sng_binary_to_parsed_gt"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.import_sng_binary_to_parsed_gt">[docs]</a><span class="k">def</span> <span class="nf">import_sng_binary_to_parsed_gt</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a goat tracker &#39;.sng&#39; binary and put it into a GTSong instance.</span>
<span class="sd">    Supports 1SID and 2SID (stereo) goattracker &#39;.sng&#39; file binaries.</span>
<span class="sd">    </span>
<span class="sd">    :param sng_bytes: Binary contents of a sng file</span>
<span class="sd">    :type sng_bytes: bytes</span>
<span class="sd">    :return: A GTSong instance holding the parsed goattracker file</span>
<span class="sd">    :rtype: GTSong</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_song</span> <span class="o">=</span> <span class="n">GTSong</span><span class="p">()</span>

    <span class="n">header</span> <span class="o">=</span> <span class="n">GtHeader</span><span class="p">()</span>

    <span class="n">header</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">header</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">GT_FILE_HEADER</span><span class="p">,</span> <span class="s2">&quot;Error: Did not find magic header used by goattracker sng files&quot;</span>

    <span class="n">header</span><span class="o">.</span><span class="n">song_name</span> <span class="o">=</span> <span class="n">get_chars</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">36</span><span class="p">])</span>
    <span class="n">header</span><span class="o">.</span><span class="n">author_name</span> <span class="o">=</span> <span class="n">get_chars</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">[</span><span class="mi">36</span><span class="p">:</span><span class="mi">68</span><span class="p">])</span>
    <span class="n">header</span><span class="o">.</span><span class="n">copyright</span> <span class="o">=</span> <span class="n">get_chars</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">[</span><span class="mi">68</span><span class="p">:</span><span class="mi">100</span><span class="p">])</span>
    <span class="n">header</span><span class="o">.</span><span class="n">num_subtunes</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">header</span><span class="o">.</span><span class="n">num_subtunes</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_SUBTUNES_PER_SONG</span><span class="p">,</span> <span class="s1">&#39;Error:  too many subtunes&#39;</span>

    <span class="n">file_index</span> <span class="o">=</span> <span class="mi">101</span>
    <span class="n">a_song</span><span class="o">.</span><span class="n">headers</span> <span class="o">=</span> <span class="n">header</span>

    <span class="c1"># From goattracker documentation: (note: doesn&#39;t account for stereo sid)</span>
    <span class="c1">#    6.1.2 ChirpSong orderlists</span>
    <span class="c1">#    ---------------------</span>
    <span class="c1">#    The orderlist structure repeats first for channels 1,2,3 of first subtune,</span>
    <span class="c1">#    then for channels 1,2,3 of second subtune etc., until all subtunes</span>
    <span class="c1">#    have been gone thru.</span>
    <span class="c1">#</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Length of this channel&#39;s orderlist n, not counting restart pos.</span>
    <span class="c1">#    +1      n+1     The orderlist data:</span>
    <span class="c1">#                    Values $00-$CF are pattern numbers</span>
    <span class="c1">#                    Values $D0-$DF are repeat commands</span>
    <span class="c1">#                    Values $E0-$FE are transpose commands</span>
    <span class="c1">#                    Value $FF is the RST endmark, followed by a byte that indicates</span>
    <span class="c1">#                    the restart position</span>

    <span class="k">if</span> <span class="n">is_2sid</span><span class="p">(</span><span class="n">file_index</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">):</span>  <span class="c1"># check if this is a &quot;stereo&quot; sid</span>
        <span class="n">a_song</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">subtune_orderlists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subtune_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">num_subtunes</span><span class="p">):</span>
        <span class="n">channels_order_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a_song</span><span class="o">.</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="n">channel_order_list</span> <span class="o">=</span> <span class="n">get_orderlist</span><span class="p">(</span><span class="n">file_index</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">)</span>
            <span class="n">file_index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_order_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">channels_order_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_order_list</span><span class="p">)</span>
        <span class="n">subtune_orderlists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channels_order_list</span><span class="p">)</span>
    <span class="n">a_song</span><span class="o">.</span><span class="n">subtune_orderlists</span> <span class="o">=</span> <span class="n">subtune_orderlists</span>

    <span class="c1"># From goattracker documentation:</span>
    <span class="c1">#    6.1.3 Instruments</span>
    <span class="c1">#    -----------------</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Amount of instruments n</span>
    <span class="c1">#</span>
    <span class="c1">#    Then, this structure repeats n times for each instrument. Instrument 0 (the</span>
    <span class="c1">#    empty instrument) is not stored.</span>
    <span class="c1">#</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Attack/Decay</span>
    <span class="c1">#    +1      byte    Sustain/Release</span>
    <span class="c1">#    +2      byte    Wavepointer</span>
    <span class="c1">#    +3      byte    Pulsepointer</span>
    <span class="c1">#    +4      byte    Filterpointer</span>
    <span class="c1">#    +5      byte    Vibrato param. (speedtable pointer)</span>
    <span class="c1">#    +6      byte    Vibraro delay</span>
    <span class="c1">#    +7      byte    Gateoff timer</span>
    <span class="c1">#    +8      byte    Hard restart/1st frame waveform</span>
    <span class="c1">#    +9      16      Instrument name</span>

    <span class="n">instruments</span> <span class="o">=</span> <span class="p">[</span><span class="n">GtInstrument</span><span class="p">()]</span>  <span class="c1"># start with empty instrument number 0</span>

    <span class="n">nonzero_inst_count</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
    <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonzero_inst_count</span><span class="p">):</span>
        <span class="n">an_instrument</span> <span class="o">=</span> <span class="n">GtInstrument</span><span class="p">(</span><span class="n">attack_decay</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">],</span> <span class="n">sustain_release</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                     <span class="n">wave_ptr</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
                                     <span class="n">filter_ptr</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span>
                                     <span class="n">vib_speedtable_ptr</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span> <span class="n">vib_delay</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span>
                                     <span class="n">gateoff_timer</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">7</span><span class="p">],</span>
                                     <span class="n">hard_restart_1st_frame_wave</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">8</span><span class="p">])</span>
        <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">9</span>

        <span class="n">an_instrument</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">an_instrument</span><span class="o">.</span><span class="n">inst_name</span> <span class="o">=</span> <span class="n">get_chars</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">:</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">16</span><span class="p">])</span>
        <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">16</span>

        <span class="n">instruments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">an_instrument</span><span class="p">)</span>
    <span class="n">a_song</span><span class="o">.</span><span class="n">instruments</span> <span class="o">=</span> <span class="n">instruments</span>

    <span class="c1"># From goattracker documentation:</span>
    <span class="c1">#    6.1.4 Tables</span>
    <span class="c1">#    ------------</span>
    <span class="c1">#    This structure repeats for each of the 4 tables (wavetable, pulsetable,</span>
    <span class="c1">#    filtertable, speedtable).</span>
    <span class="c1">#</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Amount n of rows in the table</span>
    <span class="c1">#    +1      n       Left side of the table</span>
    <span class="c1">#    +1+n    n       Right side of the table</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">a_table</span> <span class="o">=</span> <span class="n">get_table</span><span class="p">(</span><span class="n">file_index</span><span class="p">,</span> <span class="n">sng_bytes</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_table</span><span class="p">)</span>
        <span class="n">file_index</span> <span class="o">+=</span> <span class="n">a_table</span><span class="o">.</span><span class="n">row_cnt</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="p">(</span><span class="n">a_song</span><span class="o">.</span><span class="n">wave_table</span><span class="p">,</span> <span class="n">a_song</span><span class="o">.</span><span class="n">pulse_table</span><span class="p">,</span> <span class="n">a_song</span><span class="o">.</span><span class="n">filter_table</span><span class="p">,</span> <span class="n">a_song</span><span class="o">.</span><span class="n">speed_table</span><span class="p">)</span> <span class="o">=</span> <span class="n">tables</span>

    <span class="c1"># From goattracker documentation:</span>
    <span class="c1">#    6.1.5 Patterns header</span>
    <span class="c1">#    ---------------------</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Number of patterns n</span>
    <span class="c1">#</span>
    <span class="c1">#    6.1.6 Patterns</span>
    <span class="c1">#    --------------</span>
    <span class="c1">#    Repeat n times, starting from pattern number 0.</span>
    <span class="c1">#</span>
    <span class="c1">#    Offset  Size    Description</span>
    <span class="c1">#    +0      byte    Length of pattern in rows m</span>
    <span class="c1">#    +1      m*4     Groups of 4 bytes for each row of the pattern:</span>
    <span class="c1">#                    1st byte: Notenumber</span>
    <span class="c1">#                              Values $60-$BC are the notes C-0 - G#7</span>
    <span class="c1">#                              Value $BD is rest</span>
    <span class="c1">#                              Value $BE is keyoff</span>
    <span class="c1">#                              Value $BF is keyon</span>
    <span class="c1">#                              Value $FF is pattern end</span>
    <span class="c1">#                    2nd byte: Instrument number ($00-$3F)</span>
    <span class="c1">#                    3rd byte: Command ($00-$0F)</span>
    <span class="c1">#                    4th byte: Command databyte</span>

    <span class="n">num_patterns</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
    <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">pattern_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_patterns</span><span class="p">):</span>
        <span class="n">a_pattern</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_rows</span> <span class="o">=</span> <span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">num_rows</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_ROWS_PER_PATTERN</span><span class="p">,</span> <span class="s2">&quot;Too many rows in a pattern&quot;</span>
        <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">row_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="n">a_row</span> <span class="o">=</span> <span class="n">GtPatternRow</span><span class="p">(</span><span class="n">note_data</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span><span class="p">],</span> <span class="n">instr_num</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                 <span class="n">command</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">command_data</span><span class="o">=</span><span class="n">sng_bytes</span><span class="p">[</span><span class="n">file_index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">GT_NOTE_OFFSET</span> <span class="o">&lt;=</span> <span class="n">a_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_NOTE_VALUE</span><span class="p">)</span> <span class="ow">or</span> <span class="n">a_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">==</span> <span class="n">GT_PAT_END</span><span class="p">,</span> \
                <span class="s2">&quot;Error: unexpected note data value&quot;</span>
            <span class="k">assert</span> <span class="n">a_row</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_INSTR_PER_SONG</span><span class="p">,</span> <span class="s2">&quot;Error: instrument number out of range&quot;</span>
            <span class="k">assert</span> <span class="n">a_row</span><span class="o">.</span><span class="n">command</span> <span class="o">&lt;=</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="s2">&quot;Error: command number out of range&quot;</span>
            <span class="n">file_index</span> <span class="o">+=</span> <span class="mi">4</span>
            <span class="n">a_pattern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_row</span><span class="p">)</span>
        <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_pattern</span><span class="p">)</span>

    <span class="n">a_song</span><span class="o">.</span><span class="n">patterns</span> <span class="o">=</span> <span class="n">patterns</span>

    <span class="k">assert</span> <span class="n">file_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sng_bytes</span><span class="p">),</span> <span class="s2">&quot;Error: bytes parsed didn&#39;t match file bytes length&quot;</span>
    <span class="k">return</span> <span class="n">a_song</span></div>


<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Code to convert parsed gt file into rchirp</span>
<span class="c1"># </span>
<span class="c1">#</span>


<span class="n">PATTERN_END_ROW</span> <span class="o">=</span> <span class="n">GtPatternRow</span><span class="p">(</span><span class="n">note_data</span><span class="o">=</span><span class="n">GT_PAT_END</span><span class="p">)</span>


<span class="c1"># Used when &quot;running&quot; the channels to convert them to note on/off events in time</span>
<span class="k">class</span> <span class="nc">GtChannelState</span><span class="p">:</span>
    <span class="c1"># The two funktable entries are shared by all channels using a funktempo, so we have it as a</span>
    <span class="c1"># class-side var.  Note, this approach won&#39;t work if we want GtChannelState instances belonging</span>
    <span class="c1"># to and processing different songs at the same time (seems unlikely).</span>
    <span class="c1"># FUTURE: add instrument handling</span>
    <span class="c1"># FUTURE: ignoring multispeed considerations for now (would act as a simple multiplier for each)       </span>
    <span class="n">funktable</span> <span class="o">=</span> <span class="n">GT_DEFAULT_FUNKTEMPOS</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voice_num</span><span class="p">,</span> <span class="n">channel_orderlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voice_num</span> <span class="o">=</span> <span class="n">voice_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># -1 = bootstrapping value only, None = stuck in loop with no patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># -1 = bootstrapping value only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># default is to play a pattern once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># required value when bootstrapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_tick_of_row</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_transposition</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_note</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># converted to midi note number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_has_note</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if True, curr_note is immediately set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_on</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># gate bit mask on, reasserting last played note (found in self.curr_note)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_off</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># gate bit mask off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restarted</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># channel has encountered restart one or more times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span> <span class="o">=</span> <span class="n">channel_orderlist</span>  <span class="c1"># just this channel&#39;s orderlist from the subtune</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># None = no funk tempos, 0 or 1 indicates current funktable index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_tempo</span> <span class="o">=</span> <span class="n">GT_DEFAULT_TEMPO</span>

        <span class="c1"># position atop first pattern in orderlist for channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__inc_orderlist_to_next_pattern</span><span class="p">()</span>

    <span class="c1"># Advance channel/voice by a tick.  This will either:</span>
    <span class="c1"># 1) decrement a row&#39;s remaining ticks by one, or</span>
    <span class="c1"># 2) if the row&#39;s jiffies are spent, return the next row (if any)</span>
    <span class="c1"># Returns None if not returning a new row</span>
    <span class="k">def</span> <span class="nf">next_tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_song</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_tick_of_row</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If stuck in an orderlist loop that doesn&#39;t contain a pattern, then there&#39;s nothing to do</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># decrement ticks remaining in this row</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error: Can&#39;t have negative tick values&quot;</span>

        <span class="c1"># if not advancing to a new row (0 ticks left), then we&#39;re done here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">new_row_duration</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inc_to_next_row</span><span class="p">(</span><span class="n">a_song</span><span class="o">.</span><span class="n">patterns</span><span class="p">)</span>  <span class="c1"># finished last pattern row, advance to the next</span>
        <span class="c1"># get the current row in the current pattern from this channel&#39;s orderlist</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a_song</span><span class="o">.</span><span class="n">patterns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">row_index</span><span class="p">])</span>

        <span class="c1"># If row contains a note, transpose if necessary (0 = no transform)</span>
        <span class="k">if</span> <span class="n">GT_NOTE_OFFSET</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">&lt;</span> <span class="n">GT_REST</span><span class="p">:</span>  <span class="c1"># range $60 (C0) to $BC (G#7)</span>
            <span class="n">note</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_transposition</span>
            <span class="k">assert</span> <span class="n">note</span> <span class="o">&gt;=</span> <span class="n">GT_NOTE_OFFSET</span><span class="p">,</span> <span class="s2">&quot;Error: transpose dropped note below midi C0&quot;</span>
            <span class="c1"># According to docs, allowed to transpose +3 halfsteps above the highest note (G#7)</span>
            <span class="c1">#    that can be entered in the GT GUI, to create a B7</span>
            <span class="k">assert</span> <span class="n">note</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_NOTE_VALUE</span><span class="p">,</span> <span class="s2">&quot;Error: transpose raised note above midi B7&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_note</span> <span class="o">=</span> <span class="n">pattern_note_to_midi_note</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_has_note</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># GT_REST ($BD/189, gt display &quot;...&quot;):  A note continues through rest rows.  Rest does not mean</span>
        <span class="c1"># what it would in sheet music.  For our purposes, we&#39;re ignoring it</span>

        <span class="c1"># GT_KEY_OFF ($BE/190, gt display &quot;---&quot;): Unsets the gate bit mask.  This starts the release phase</span>
        <span class="c1"># of the ADSR.</span>
        <span class="c1"># Going to ignore any effects gateoff timer and hardrestart values might have on perceived note end</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">==</span> <span class="n">GT_KEY_OFF</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_note</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_off</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># GT_KEY_ON ($BF/191, gt display &quot;+++&quot;): Sets the gate bit mask (ANDed with data from the wavetable).</span>
        <span class="c1"># If no prior note has been started, then nothing will happen.  If a note is playing,</span>
        <span class="c1"># nothing will happen (to the note, to the instrument, etc.).  If a note was turned off,</span>
        <span class="c1"># this will restart it, but will not restart the instrument.</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">==</span> <span class="n">GT_KEY_ON</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_note</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_on</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Notes on funktempo (all this logic gleaned from reading through gplay.c)</span>
        <span class="c1"># </span>
        <span class="c1"># Funktempo allows switching between two tempos on alternating pattern rows, to achieve</span>
        <span class="c1"># a &quot;swing&quot; or more organic feel.</span>
        <span class="c1"># - for non-multispeed songs, it defaults to 9 and 6 </span>
        <span class="c1"># </span>
        <span class="c1"># The funktempo command is $E followed by an index to a single row in the speed table</span>
        <span class="c1"># - The left/right values in the speedtable row contain the two (alternating) tempo values</span>
        <span class="c1"># - Under the covers (in gplay.c), the array funktable[2] holds the two tempos</span>
        <span class="c1">#    - e.g., command E04 points to speedtable at index 4.  If the speedtable row contains</span>
        <span class="c1">#      01:09 06, then the alternating tempos are 9 and 6.  For a 4x-multispeed, these</span>
        <span class="c1">#      would need to be set instead to 01:24 18</span>
        <span class="c1">#    - the two values in funktable[] are global to all participating channels</span>
        <span class="c1"># - The command applies to all channels (3 or 6 for stereo) and all channels are set to</span>
        <span class="c1">#   tempo 0</span>
        <span class="c1"># </span>
        <span class="c1"># The tempo command is $F, and &quot;tempos&quot; $00 and $01 change all channels to the tempo that&#39;s</span>
        <span class="c1"># been previously set in funktable[0] or funktable[1] respectively, and every subsequent</span>
        <span class="c1"># row will alternate between the [0] and [1] entries of the funktable.  In otherwords,</span>
        <span class="c1"># you can choose which half of the funktempo to start with.</span>
        <span class="c1"># - Values $80 and $81 are like $00 and $01, but apply funktempo to just the current channel</span>
        <span class="c1"># - Since the $E command sets all tempos to 0 (see above), it will always start with</span>
        <span class="c1">#   funktable[0]&#39;s tempo (set by the left-side entry in the speed table).  But $F can choose</span>
        <span class="c1">#   to start with the (previously-set) first or second value in the funktempo pair.</span>

        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">command</span> <span class="o">==</span> <span class="mh">0x0E</span><span class="p">:</span>  <span class="c1"># funktempo command</span>
            <span class="n">speed_table_index</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span>
            <span class="k">if</span> <span class="n">speed_table_index</span> <span class="o">&gt;</span> <span class="n">a_song</span><span class="o">.</span><span class="n">speed_table</span><span class="o">.</span><span class="n">row_cnt</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChiptuneSAKContentError</span><span class="p">(</span><span class="s2">&quot;Error: speed table index </span><span class="si">%d</span><span class="s2"> too big for table of size </span><span class="si">%d</span><span class="s2">&quot;</span>
                                              <span class="o">%</span> <span class="p">(</span><span class="n">speed_table_index</span><span class="p">,</span> <span class="n">a_song</span><span class="o">.</span><span class="n">speed_table</span><span class="o">.</span><span class="n">row_cnt</span><span class="p">))</span>

            <span class="c1"># look up the two funk tempos in the speed table and set the channel-shared funktable</span>
            <span class="n">speed_table_index</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># convert to zero-indexing</span>
            <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_song</span><span class="o">.</span><span class="n">speed_table</span><span class="o">.</span><span class="n">left_col</span><span class="p">[</span><span class="n">speed_table_index</span><span class="p">]</span>
            <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_song</span><span class="o">.</span><span class="n">speed_table</span><span class="o">.</span><span class="n">right_col</span><span class="p">[</span><span class="n">speed_table_index</span><span class="p">]</span>

            <span class="n">new_row_duration</span> <span class="o">=</span> <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Record global funktempo change</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 0 will later become the tempo in funktable entry 0</span>
        <span class="k">elif</span> <span class="n">row</span><span class="o">.</span><span class="n">command</span> <span class="o">==</span> <span class="n">GT_TEMPO_CHNG_CMD</span><span class="p">:</span>
            <span class="c1"># From docs:</span>
            <span class="c1">#    Values $03-$7F set tempo on all channels, values $83-$FF only on current channel (subtract</span>
            <span class="c1">#    $80 to get actual tempo). Tempos $00-$01 recall the funktempo values set by EXY command.</span>

            <span class="c1"># Note: The higher voice number seems to win ties on simultaneous speed changes</span>

            <span class="k">assert</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">],</span> \
                <span class="s2">&quot;Unimplemented: Don&#39;t know how to support tempo change with value </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span>

            <span class="n">new_row_duration</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">&amp;</span> <span class="mi">127</span>  <span class="c1"># don&#39;t care if it&#39;s global or local</span>
            <span class="k">if</span> <span class="n">new_row_duration</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_row_duration</span> <span class="o">=</span> <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="n">new_row_duration</span><span class="p">]</span>

            <span class="c1"># Record global tempo change</span>
            <span class="c1">#   From looking at the gt source code (at least for the goat tracker gui&#39;s gplay.c)</span>
            <span class="c1">#   when a CMD_SETTEMPO happens (for one or for all three/six channels), the tempos immediately</span>
            <span class="c1">#   change, but the ticks remaining on each channel&#39;s current row (in progress) is left alone --</span>
            <span class="c1">#   another detail that would have been nice to have had in the documentation.</span>
            <span class="k">if</span> <span class="mh">0x03</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">&lt;=</span> <span class="mh">0x7F</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span>

            <span class="c1"># Record tempo change for just the given channel</span>
            <span class="k">if</span> <span class="mh">0x83</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">-</span> <span class="mh">0x80</span>

                <span class="c1"># Record global funktempo change (funktable tempo entry 0 or 1)</span>
            <span class="k">if</span> <span class="mh">0x00</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">&lt;=</span> <span class="mh">0x01</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span>

            <span class="c1"># Record funktempo change for just the given channel (funktable tempo entry 0 or 1)</span>
            <span class="k">if</span> <span class="mh">0x80</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">&lt;=</span> <span class="mh">0x81</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">-</span> <span class="mh">0x80</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># given no tempo command on this row (0x0E or 0x0F), if we&#39;re in funktempo mode, time to alternate</span>
            <span class="c1"># our funktempo</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">^=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_funktable_index</span>
                <span class="n">new_row_duration</span> <span class="o">=</span> <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_funktable_index</span><span class="p">]</span>

        <span class="c1"># init duration of this row</span>
        <span class="c1"># (if it hasn&#39;t started to count down, a row&#39;s init duration can get overwritten by</span>
        <span class="c1"># another channel&#39;s global temp setting, performed later in this code)</span>
        <span class="k">if</span> <span class="n">new_row_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">=</span> <span class="n">new_row_duration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_tempo</span>

        <span class="c1"># FUTUREs: Possibly handle some of the (below) commands in the future?</span>
        <span class="c1"># from docs:</span>
        <span class="c1">#    Command 1XY: Portamento up. XY is an index to a 16-bit speed value in the speedtable.</span>
        <span class="c1">#</span>
        <span class="c1">#    Command 2XY: Portamento down. XY is an index to a 16-bit speed value in the speedtable.</span>
        <span class="c1">#</span>
        <span class="c1">#    Command 3XY: Toneportamento. Raise or lower pitch until target note has been reached. XY is an index</span>
        <span class="c1">#    to a 16-bit speed value in the speedtable, or $00 for &quot;tie-note&quot; effect (move pitch instantly to</span>
        <span class="c1">#    target note)</span>
        <span class="c1">#</span>
        <span class="c1">#    Command DXY: Set mastervolume to Y, if X is $0. If X is not $0, value XY is</span>
        <span class="c1">#    copied to the timing mark location, which is playeraddress+$3F.    </span>

        <span class="k">return</span> <span class="n">row</span>

    <span class="c1"># Advance to next row in pattern.  If pattern end, then go to row 0 of next pattern in orderlist</span>
    <span class="k">def</span> <span class="nf">inc_to_next_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_index</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># init val is -1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_has_note</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_on</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_has_key_off</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_tick_of_row</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">patterns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span><span class="p">]][</span><span class="bp">self</span><span class="o">.</span><span class="n">row_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">PATTERN_END_ROW</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error: negative number of remaining plays for pattern&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">row_index</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># all patterns are guaranteed to start with at least one meaningful (not end mark) row</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># all done with this pattern, moving on</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__inc_orderlist_to_next_pattern</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__inc_orderlist_to_next_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># patterns default to one playthrough unless otherwise specified</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># bootstraps at -1</span>
            <span class="n">a_byte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span><span class="p">]</span>

            <span class="c1"># parse transpose</span>
            <span class="c1"># Transpose is in half steps.  Transposes changes are absolute, not additive.</span>
            <span class="c1">#   If transpose combined with repeat, transpose must come before a repeat</span>
            <span class="c1">#   Testing shows transpose ranges from &#39;-F&#39; (225) to &#39;+E&#39; (254) in orderlist</span>
            <span class="c1">#   Bug in goattracker documentation: says range is $E0 (224) to $FE (254)</span>
            <span class="c1">#   I&#39;m assuming byte 224 is never used in orderlists</span>
            <span class="k">assert</span> <span class="n">a_byte</span> <span class="o">!=</span> <span class="mh">0xE0</span><span class="p">,</span> <span class="s2">&quot;Unimplemented: Don&#39;t believe byte E0 should occur in the orderlist&quot;</span>
            <span class="k">if</span> <span class="mh">0xE1</span> <span class="o">&lt;=</span> <span class="n">a_byte</span> <span class="o">&lt;=</span> <span class="mh">0xFE</span><span class="p">:</span>  <span class="c1"># F0 = +0 = no transposition</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">curr_transposition</span> <span class="o">=</span> <span class="n">a_byte</span> <span class="o">-</span> <span class="mh">0xF0</span>  <span class="c1"># transpose range is -15 to +14</span>
                <span class="k">continue</span>

            <span class="c1"># parse repeat</span>
            <span class="c1"># Repeat values 1 to 16.  In tracker, instead of R0..RF, it&#39;s R1..RF,R0</span>
            <span class="c1">#   i.e., &#39;R0&#39;=223=16reps, &#39;RF&#39;=222=15 reps, &#39;R1&#39;=208=1rep</span>
            <span class="c1"># Note:  Repeat n really means repeat n-1, so it&#39;s actually &quot;number of times to play&quot;</span>
            <span class="c1">#    So R1 (repeat 1) is essentially a NOP</span>
            <span class="k">if</span> <span class="mh">0xD0</span> <span class="o">&lt;=</span> <span class="n">a_byte</span> <span class="o">&lt;=</span> <span class="mh">0xDF</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pat_remaining_plays</span> <span class="o">=</span> <span class="n">a_byte</span> <span class="o">-</span> <span class="mh">0xCF</span>
                <span class="k">continue</span>

            <span class="c1"># parse RST (restart)</span>
            <span class="k">if</span> <span class="n">a_byte</span> <span class="o">==</span> <span class="n">GT_OL_RST</span><span class="p">:</span>  <span class="c1"># RST ($FF)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">restarted</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># byte following RST is orderlist restart index</span>
                <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span>  <span class="c1"># byte containing RST</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># perform orderlist &quot;goto&quot; jump</span>
                <span class="c1"># check if there&#39;s at least one pattern between the restart location and the RST</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_orderlist</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">GT_MAX_PATTERNS_PER_SONG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>  <span class="c1"># no pattern to ultimately end up on, so we&#39;re done</span>
                <span class="c1"># continue loop, just in case we land on a repeat or transpose that needs resolving</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">orderlist_index</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># &quot;undo&quot; +1 at start of loop</span>
                <span class="k">continue</span>

                <span class="c1"># parse pattern</span>
            <span class="k">if</span> <span class="n">a_byte</span> <span class="o">&lt;</span> <span class="n">GT_MAX_PATTERNS_PER_SONG</span><span class="p">:</span>  <span class="c1"># if it&#39;s a pattern</span>
                <span class="k">break</span>  <span class="c1"># found one, done parsing</span>

            <span class="k">raise</span> <span class="n">ChiptuneSAKException</span><span class="p">(</span><span class="s2">&quot;Error: found uninterpretable value </span><span class="si">%d</span><span class="s2"> in orderlist&quot;</span> <span class="o">%</span> <span class="n">a_byte</span><span class="p">)</span>


<div class="viewcode-block" id="import_parsed_gt_to_rchirp"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.import_parsed_gt_to_rchirp">[docs]</a><span class="k">def</span> <span class="nf">import_parsed_gt_to_rchirp</span><span class="p">(</span><span class="n">sng_data</span><span class="p">,</span> <span class="n">subtune_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the parsed goattracker file into rchirp </span>
<span class="sd">    </span>
<span class="sd">    :param sng_data: Parsed goattracker file</span>
<span class="sd">    :type sng_data: GTSong</span>
<span class="sd">    :param subtune_num: The subtune number to convert to rchirp, defaults to 0</span>
<span class="sd">    :type subtune_num: int, optional</span>
<span class="sd">    :return: rchirp song instance</span>
<span class="sd">    :rtype: RChirpSong</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># init state holders for each channel to use as we step through each tick (aka jiffy aka frame)</span>
    <span class="n">channels_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">GtChannelState</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sng_data</span><span class="o">.</span><span class="n">subtune_orderlists</span><span class="p">[</span><span class="n">subtune_num</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sng_data</span><span class="o">.</span><span class="n">num_channels</span><span class="p">)]</span>

    <span class="n">rchirp_song</span> <span class="o">=</span> <span class="n">ctsRChirp</span><span class="o">.</span><span class="n">RChirpSong</span><span class="p">()</span>
    <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctsRChirp</span><span class="o">.</span><span class="n">RChirpVoice</span><span class="p">(</span><span class="n">rchirp_song</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sng_data</span><span class="o">.</span><span class="n">num_channels</span><span class="p">)]</span>

    <span class="c1"># TODO: Make track assignment to SID groupings not hardcoded</span>
    <span class="k">if</span> <span class="n">sng_data</span><span class="o">.</span><span class="n">is_stereo</span><span class="p">:</span>
        <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voice_groups</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voice_groups</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

        <span class="c1"># Handle the rarely-used sneaky default global tempo setting</span>
    <span class="c1"># from docs:</span>
    <span class="c1">#    For very optimized songdata &amp; player you can refrain from using any pattern</span>
    <span class="c1">#    commands and rely on the instruments&#39; step-programming. Even in this case, you</span>
    <span class="c1">#    can set song startup default tempo with the Attack/Decay parameter of the last</span>
    <span class="c1">#    instrument (63/0x3F), if you otherwise leave this instrument unused.</span>

    <span class="c1"># TODO: This code block is untested</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sng_data</span><span class="o">.</span><span class="n">instruments</span><span class="p">)</span> <span class="o">==</span> <span class="n">GT_MAX_INSTR_PER_SONG</span><span class="p">:</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="n">sng_data</span><span class="o">.</span><span class="n">instruments</span><span class="p">[</span><span class="n">GT_MAX_INSTR_PER_SONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">attack_decay</span>
        <span class="k">if</span> <span class="mh">0x03</span> <span class="o">&lt;=</span> <span class="n">ad</span> <span class="o">&lt;=</span> <span class="mh">0x7F</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">channels_state</span><span class="p">:</span>
                <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span> <span class="o">=</span> <span class="n">ad</span>

    <span class="n">global_tick</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># Step through each tick.  For each tick, evaluate the state of each channel.</span>
    <span class="c1"># Continue until all channels have hit the end of their respective orderlists</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">restarted</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">channels_state</span><span class="p">):</span>
        <span class="c1"># When not using multispeed, tempo = ticks per row = screen refreshes per row.</span>
        <span class="c1"># &#39;Ticks&#39; on C64 are also &#39;frames&#39; or &#39;jiffies&#39;.  Each tick in PAL is around 20ms,</span>
        <span class="c1"># and ~16.7‬ms on NTSC.</span>
        <span class="c1"># (in contrast, for a multispeed of 2, there would be two music updates per frame)</span>
        <span class="n">global_tick</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">global_tempo_change</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels_state</span><span class="p">):</span>
            <span class="c1"># Either reduce time left on this row, or get the next new goattracker data row</span>
            <span class="n">gt_row</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">next_tick</span><span class="p">(</span><span class="n">sng_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gt_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if we didn&#39;t advance to a new row...</span>
                <span class="k">continue</span>

            <span class="n">rc_row</span> <span class="o">=</span> <span class="n">ctsRChirp</span><span class="o">.</span><span class="n">RChirpRow</span><span class="p">()</span>
            <span class="n">rc_row</span><span class="o">.</span><span class="n">jiffy_num</span> <span class="o">=</span> <span class="n">global_tick</span>
            <span class="n">rc_row</span><span class="o">.</span><span class="n">jiffy_len</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span>

            <span class="c1"># TODO: add instrument data to RChirpRows</span>
            <span class="c1"># KeyOff (only recorded if there&#39;s a curr_note defined)</span>
            <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">row_has_key_off</span><span class="p">:</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">curr_note</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">gate</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># KeyOn (only recorded if there&#39;s a curr_note defined)</span>
            <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">row_has_key_on</span><span class="p">:</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">curr_note</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">gate</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># if note_data is an actual note, then cs.curr_note has been updated</span>
            <span class="k">elif</span> <span class="n">cs</span><span class="o">.</span><span class="n">row_has_note</span><span class="p">:</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">curr_note</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">gate</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># process tempo changes</span>
            <span class="c1"># Note: local_tempo_update and global_tempo_update init to None when new row fetched</span>
            <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Apply local (single channel) tempo change</span>
                <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">local_tempo_update</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">local_tempo_update</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s an index to a funktable tempo</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">local_tempo_update</span>
                    <span class="c1"># convert into a normal tempo change</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span> <span class="o">=</span> <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span><span class="p">]</span>
                <span class="n">rc_row</span><span class="o">.</span><span class="n">jiffy_len</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span>

            <span class="c1"># this channel signals a global tempo change that will affect all the channels</span>
            <span class="c1"># once out of this per-channel loop</span>
            <span class="k">elif</span> <span class="n">cs</span><span class="o">.</span><span class="n">global_tempo_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">global_tempo_change</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">global_tempo_update</span>

            <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append_row</span><span class="p">(</span><span class="n">rc_row</span><span class="p">)</span>

        <span class="c1"># By this point, we&#39;ve passed through all channels for this particular tick</span>
        <span class="c1"># If more than one channel made a tempo change, the global tempo change on the highest</span>
        <span class="c1"># voice/channel number wins (consistent with goattracker behavior)</span>
        <span class="k">if</span> <span class="n">global_tempo_change</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels_state</span><span class="p">):</span>  <span class="c1"># Time to apply the global changes:</span>
                <span class="k">if</span> <span class="n">global_tempo_change</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># funk tempo mode off</span>
                    <span class="n">new_tempo</span> <span class="o">=</span> <span class="n">global_tempo_change</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s an index to a funktable tempo</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span> <span class="o">=</span> <span class="n">global_tempo_change</span>  <span class="c1"># stateful funky tracking</span>
                    <span class="c1"># convert into a normal tempo change</span>
                    <span class="n">new_tempo</span> <span class="o">=</span> <span class="n">GtChannelState</span><span class="o">.</span><span class="n">funktable</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">curr_funktable_index</span><span class="p">]</span>

                <span class="n">current_rc_row</span> <span class="o">=</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">last_row</span>

                <span class="c1"># If row state is in progress, leave its remaining ticks alone.</span>
                <span class="c1"># But if it&#39;s the very start of a new row, then override with the new global tempo</span>
                <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">first_tick_of_row</span><span class="p">:</span>
                    <span class="n">cs</span><span class="o">.</span><span class="n">row_ticks_left</span> <span class="o">=</span> <span class="n">new_tempo</span>
                    <span class="n">current_rc_row</span><span class="o">.</span><span class="n">jiffy_len</span> <span class="o">=</span> <span class="n">new_tempo</span>

                <span class="n">cs</span><span class="o">.</span><span class="n">curr_tempo</span> <span class="o">=</span> <span class="n">new_tempo</span>

    <span class="c1"># Create note offs once all channels have hit their orderlist restart one or more times</span>
    <span class="c1">#    Ok, cheesy hack here.  The loop above repeats until all tracks have had a chance to restart, but it</span>
    <span class="c1">#    allows each voice to load in one row after that point.  Taking advantage of that, we modify that</span>
    <span class="c1">#    row with note off events, looking backwards to previous rows to see what the last note was to use</span>
    <span class="c1">#    in the note off events.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels_state</span><span class="p">):</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">reversed_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">rows</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="k">for</span> <span class="n">seek_index</span> <span class="ow">in</span> <span class="n">reversed_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># skip largest row num, and work backwards</span>
            <span class="k">if</span> <span class="n">rows</span><span class="p">[</span><span class="n">seek_index</span><span class="p">]</span><span class="o">.</span><span class="n">note_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rows</span><span class="p">[</span><span class="n">reversed_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">note_num</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">seek_index</span><span class="p">]</span><span class="o">.</span><span class="n">note_num</span>
                <span class="n">rows</span><span class="p">[</span><span class="n">reversed_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">gate</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># gate off</span>
                <span class="k">break</span>

    <span class="c1"># In rchirp (as of right now), all tempo changes are specific to each channel, even if the</span>
    <span class="c1"># tempo change was originally global.  This can can lead to lots of tempo changes when</span>
    <span class="c1"># unrolling a global funk tempo.</span>
    <span class="k">for</span> <span class="n">voice</span> <span class="ow">in</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">:</span>
        <span class="n">prev_tempo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">rchirp_row</span> <span class="ow">in</span> <span class="n">voice</span><span class="o">.</span><span class="n">sorted_rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">jiffy_len</span> <span class="o">!=</span> <span class="n">prev_tempo</span><span class="p">:</span>
                <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_jiffy_tempo</span> <span class="o">=</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">jiffy_len</span>
                <span class="n">prev_tempo</span> <span class="o">=</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">jiffy_len</span>

    <span class="c1"># TODO: There is not yet generalized handling for instruments when creating output goattracker</span>
    <span class="c1"># binaries.  This code will just stub in a default instrument for each voice on that voice&#39;s</span>
    <span class="c1"># first note (if any).</span>
    <span class="k">for</span> <span class="n">voice</span> <span class="ow">in</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rchirp_row</span> <span class="ow">in</span> <span class="n">voice</span><span class="o">.</span><span class="n">sorted_rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">note_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_instrument</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_instrument</span> <span class="o">=</span> <span class="n">DEFAULT_INSTRUMENT</span>
                <span class="k">break</span>

    <span class="c1"># Before returning the rchirp song, might as well make use of our test cases here</span>
    <span class="n">rchirp_song</span><span class="o">.</span><span class="n">integrity_check</span><span class="p">()</span>  <span class="c1"># Will throw assertions if there are any problems</span>
    <span class="k">assert</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">is_contiguous</span><span class="p">(),</span> <span class="s2">&quot;Error: rchirp representation should not be sparse&quot;</span>

    <span class="k">return</span> <span class="n">rchirp_song</span></div>


<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Code to convert rchirp to goattracker file</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="n">PATTERN_EMPTY_ROW</span> <span class="o">=</span> <span class="n">GtPatternRow</span><span class="p">(</span><span class="n">note_data</span><span class="o">=</span><span class="n">GT_REST</span><span class="p">)</span>

<span class="n">TRUNCATE_IF_TOO_BIG</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1"># A Procrustean bed for GT text fields.  Can accept a string or bytes.</span>
<span class="k">def</span> <span class="nf">pad_or_truncate</span><span class="p">(</span><span class="n">to_pad</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_pad</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">to_pad</span> <span class="o">=</span> <span class="n">to_pad</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">to_pad</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">length</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">instrument_to_bytes</span><span class="p">(</span><span class="n">instrument</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">instrument</span><span class="o">.</span><span class="n">attack_decay</span><span class="p">,</span> <span class="n">instrument</span><span class="o">.</span><span class="n">sustain_release</span><span class="p">,</span>
                     <span class="n">instrument</span><span class="o">.</span><span class="n">wave_ptr</span><span class="p">,</span> <span class="n">instrument</span><span class="o">.</span><span class="n">pulse_ptr</span><span class="p">,</span> <span class="n">instrument</span><span class="o">.</span><span class="n">filter_ptr</span><span class="p">,</span>
                     <span class="n">instrument</span><span class="o">.</span><span class="n">vib_speedtable_ptr</span><span class="p">,</span> <span class="n">instrument</span><span class="o">.</span><span class="n">vib_delay</span><span class="p">,</span> <span class="n">instrument</span><span class="o">.</span><span class="n">gateoff_timer</span><span class="p">,</span>
                     <span class="n">instrument</span><span class="o">.</span><span class="n">hard_restart_1st_frame_wave</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">pad_or_truncate</span><span class="p">(</span><span class="n">instrument</span><span class="o">.</span><span class="n">inst_name</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="export_rchirp_to_gt"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.export_rchirp_to_gt">[docs]</a><span class="k">def</span> <span class="nf">export_rchirp_to_gt</span><span class="p">(</span><span class="n">rchirp_song</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">,</span> <span class="n">end_with_repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pattern_len</span><span class="o">=</span><span class="mi">126</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rchirp into a goattracker .sng file.</span>
<span class="sd">    </span>
<span class="sd">    :param output_filename: Output path and filename</span>
<span class="sd">    :type output_filename: string</span>
<span class="sd">    :param rchirp_song: The rchirp song to convert</span>
<span class="sd">    :type rchirp_song: RChirpSong</span>
<span class="sd">    :param end_with_repeat: True if song should repeat when finished, defaults to False</span>
<span class="sd">    :type end_with_repeat: bool, optional</span>
<span class="sd">    :param pattern_len: Maximum pattern lengths to create</span>
<span class="sd">    :type pattern_len: int, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="n">export_rchirp_to_gt_binary</span><span class="p">(</span><span class="n">rchirp_song</span><span class="p">,</span> <span class="n">end_with_repeat</span><span class="p">,</span> <span class="n">pattern_len</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
        <span class="n">out_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">make_orderlist_entry</span><span class="p">(</span><span class="n">pattern_number</span><span class="p">,</span> <span class="n">transposition</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">prev_transposition</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes orderlist entries from a pattern number, a transposition, and a number of repeats.</span>

<span class="sd">    :param pattern_number: pattern number</span>
<span class="sd">    :type pattern_number: int</span>
<span class="sd">    :param transposition: transposition in semitones</span>
<span class="sd">    :type transposition: int</span>
<span class="sd">    :param repeats: Number of times to repeat</span>
<span class="sd">    :type repeats: int</span>
<span class="sd">    :param prev_transposition: Previous transposition</span>
<span class="sd">    :type prev_transposition: int</span>
<span class="sd">    :return: list of orderlist command</span>
<span class="sd">    :rtype: list of int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Only insert transposition (absolute) when it changes</span>
    <span class="k">if</span> <span class="n">transposition</span> <span class="o">==</span> <span class="n">prev_transposition</span><span class="p">:</span>
        <span class="n">transposition</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="o">-</span><span class="mi">15</span> <span class="o">&lt;=</span> <span class="n">transposition</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">:</span>  <span class="c1"># Check that transposition is in allowed range</span>
        <span class="n">transposition</span> <span class="o">+=</span> <span class="mh">0xF0</span>  <span class="c1"># offset for transpositions</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Instead of dying, fix transpositions by doing octave offsets until it is within range.</span>
        <span class="k">while</span> <span class="n">transposition</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">:</span>
            <span class="n">transposition</span> <span class="o">-=</span> <span class="mi">12</span>
        <span class="k">while</span> <span class="n">transposition</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">15</span><span class="p">:</span>
            <span class="n">transposition</span> <span class="o">+=</span> <span class="mi">12</span>
        <span class="k">assert</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span> <span class="o">&lt;=</span> <span class="n">transposition</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">),</span> <span class="s2">&quot;bad transposition = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">transposition</span>
        <span class="n">transposition</span> <span class="o">+=</span> <span class="mh">0xF0</span>

    <span class="c1"># Longest possible repeat is 16, so generate as many of those as needed</span>
    <span class="k">while</span> <span class="n">repeats</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">transposition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transposition</span><span class="p">)</span>  <span class="c1"># If no transposition, leave it off.</span>
            <span class="n">transposition</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Only add transposition once</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mh">0xD0</span><span class="p">)</span>  <span class="c1"># Repeat 16 times</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern_number</span><span class="p">)</span>
        <span class="n">repeats</span> <span class="o">-=</span> <span class="mi">16</span>

    <span class="c1"># Now do the last one if there are any left (usually this is the only part accessed)</span>
    <span class="k">if</span> <span class="n">repeats</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">transposition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transposition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">repeats</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If only one time, no need to put anything in.</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repeats</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mh">0xD0</span><span class="p">)</span>  <span class="c1"># Repeat N times</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern_number</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Byte value error in orderlist&quot;</span>
    <span class="k">return</span> <span class="n">retval</span>


<div class="viewcode-block" id="export_rchirp_to_gt_binary"><a class="viewcode-back" href="../utilities.html#ctsGoatTracker.export_rchirp_to_gt_binary">[docs]</a><span class="k">def</span> <span class="nf">export_rchirp_to_gt_binary</span><span class="p">(</span><span class="n">rchirp_song</span><span class="p">,</span> <span class="n">end_with_repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pattern_len</span><span class="o">=</span><span class="mi">126</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rchirp into a goattracker .sng binary.</span>
<span class="sd">    </span>
<span class="sd">    :param rchirp_song: The rchirp song to convert</span>
<span class="sd">    :type rchirp_song: RChirpSong</span>
<span class="sd">    :param end_with_repeat: True if song should repeat when finished, defaults to False</span>
<span class="sd">    :type end_with_repeat: bool, optional</span>
<span class="sd">    :param pattern_len: Maximum pattern lengths to create</span>
<span class="sd">    :type pattern_len: int, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_stereo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ChiptuneSAKContentError</span><span class="p">(</span><span class="s2">&quot;Error: Stereo SID can only support up to 6 voices&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_stereo</span><span class="p">:</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">patterns</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># can be shared across all channels</span>
    <span class="n">orderlists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)]</span>  <span class="c1"># Note: this is bad: [[]] * len(tracknums)</span>
    <span class="n">too_many_patterns</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># If the song has gone through a compression algorithm, the compressed property will be set to True</span>
    <span class="k">if</span> <span class="n">rchirp_song</span><span class="o">.</span><span class="n">compressed</span><span class="p">:</span>
        <span class="c1"># Convert the patterns to goattracker patterns</span>
        <span class="n">prev_instrument</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># TODO: Default instrument 1, this must be generalized</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">patterns</span><span class="p">):</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>  <span class="c1"># initialize new empty pattern</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="n">gt_row</span> <span class="o">=</span> <span class="n">GtPatternRow</span><span class="p">()</span>  <span class="c1"># make a new empty pattern row</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">gate</span><span class="p">:</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">=</span> <span class="n">midi_note_to_pattern_note</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">note_num</span><span class="p">)</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">instr_num</span>
                <span class="k">elif</span> <span class="n">r</span><span class="o">.</span><span class="n">gate</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># if ending a note (&#39;false&#39; check because tri-state)</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">=</span> <span class="n">GT_KEY_OFF</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">instr_num</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">new_jiffy_tempo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">GT_TEMPO_CHNG_CMD</span>
                    <span class="c1"># insert local channel tempo change</span>
                    <span class="n">gt_row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">new_jiffy_tempo</span> <span class="o">+</span> <span class="mh">0x80</span>
                <span class="n">pattern</span> <span class="o">+=</span> <span class="n">gt_row</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
            <span class="n">pattern</span> <span class="o">+=</span> <span class="n">PATTERN_END_ROW</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>  <span class="c1"># finish with end row marker</span>
            <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">):</span>
            <span class="n">prev_transposition</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Start out each voice with default transposition of 0</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">orderlist</span><span class="p">:</span>
                <span class="n">ol_entry</span> <span class="o">=</span> <span class="n">make_orderlist_entry</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pattern_num</span><span class="p">,</span>
                                                <span class="n">entry</span><span class="o">.</span><span class="n">transposition</span><span class="p">,</span>
                                                <span class="n">entry</span><span class="o">.</span><span class="n">repeats</span><span class="p">,</span>
                                                <span class="n">prev_transposition</span><span class="p">)</span>
                <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ol_entry</span><span class="p">)</span>
                <span class="n">prev_transposition</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">transposition</span>

    <span class="c1"># Uncompressed song</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Convert the sparse representation into separate patterns (of bytes)</span>
        <span class="n">curr_pattern_num</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># for each channel, get its rows, and create patterns, adding them to the </span>
        <span class="c1"># channel&#39;s orderlist</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rchirp_voice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">voices</span><span class="p">):</span>
            <span class="n">rchirp_rows</span> <span class="o">=</span> <span class="n">rchirp_voice</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">pattern_row_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>  <span class="c1"># create a new, empty pattern</span>
            <span class="n">max_row</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rchirp_rows</span><span class="p">)</span>
            <span class="n">prev_instrument</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># TODO: Default instrument 1, this must be generalized</span>

            <span class="c1"># Iterate across row num span (inclusive).  Would normally iterated over</span>
            <span class="c1"># sorted rchirp_rows dict keys, but since rchirp is allowed to be sparse</span>
            <span class="c1"># we&#39;re being careful here to insert an empty row for missing row num keys</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                <span class="c1"># Convert each rchirp_row into the gt_row (used for binary gt row representation)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rchirp_rows</span><span class="p">:</span>
                    <span class="n">rchirp_row</span> <span class="o">=</span> <span class="n">rchirp_rows</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">gt_row</span> <span class="o">=</span> <span class="n">GtPatternRow</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">gate</span><span class="p">:</span>  <span class="c1"># if starting a note</span>
                        <span class="n">gt_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">=</span> <span class="n">midi_note_to_pattern_note</span><span class="p">(</span><span class="n">rchirp_row</span><span class="o">.</span><span class="n">note_num</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="n">GT_NOTE_OFFSET</span> <span class="o">&lt;=</span> <span class="n">gt_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">&lt;=</span> <span class="n">GT_MAX_NOTE_VALUE</span><span class="p">,</span> <span class="s1">&#39;Illegal note number&#39;</span>

                        <span class="c1"># TODO: RChirp rows now include instrument; incorporate that into this code</span>
                        <span class="c1"># only bother to populate instrument if there&#39;s a new note</span>
                        <span class="k">if</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_instrument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">gt_row</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">=</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_instrument</span>
                            <span class="n">prev_instrument</span> <span class="o">=</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_instrument</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># unlike SID-Wizard which only asserts instrument changes (on any row),</span>
                            <span class="c1"># goattracker asserts the current instrument with every note</span>
                            <span class="c1"># (goattracker can assert instrument without note, but that&#39;s a NOP)</span>
                            <span class="n">gt_row</span><span class="o">.</span><span class="n">instr_num</span> <span class="o">=</span> <span class="n">prev_instrument</span>

                    <span class="k">elif</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">gate</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># if ending a note (&#39;false&#39; check because tri-state)</span>
                        <span class="n">gt_row</span><span class="o">.</span><span class="n">note_data</span> <span class="o">=</span> <span class="n">GT_KEY_OFF</span>

                    <span class="k">if</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_jiffy_tempo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">gt_row</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">GT_TEMPO_CHNG_CMD</span>
                        <span class="c1"># insert local channel tempo change</span>
                        <span class="n">gt_row</span><span class="o">.</span><span class="n">command_data</span> <span class="o">=</span> <span class="n">rchirp_row</span><span class="o">.</span><span class="n">new_jiffy_tempo</span> <span class="o">+</span> <span class="mh">0x80</span>
                    <span class="n">pattern</span> <span class="o">+=</span> <span class="n">gt_row</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pattern</span> <span class="o">+=</span> <span class="n">PATTERN_EMPTY_ROW</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>

                <span class="n">pattern_row_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># pattern_len notes: index 0 to len-1 for data, index len for 0xFF pattern end mark</span>
                <span class="k">if</span> <span class="n">pattern_row_index</span> <span class="o">==</span> <span class="n">pattern_len</span><span class="p">:</span>  <span class="c1"># if pattern is full</span>
                    <span class="n">pattern</span> <span class="o">+=</span> <span class="n">PATTERN_END_ROW</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>  <span class="c1"># finish with end row marker</span>
                    <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_pattern_num</span><span class="p">)</span>  <span class="c1"># append to orderlist for this channel</span>
                    <span class="n">curr_pattern_num</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">curr_pattern_num</span> <span class="o">&gt;=</span> <span class="n">GT_MAX_PATTERNS_PER_SONG</span><span class="p">:</span>
                        <span class="n">too_many_patterns</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
                    <span class="n">pattern_row_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">too_many_patterns</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if there&#39;s a final partially-filled pattern, add it</span>
                <span class="n">pattern</span> <span class="o">+=</span> <span class="n">PATTERN_END_ROW</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
                <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_pattern_num</span><span class="p">)</span>
                <span class="n">curr_pattern_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">curr_pattern_num</span> <span class="o">&gt;=</span> <span class="n">GT_MAX_PATTERNS_PER_SONG</span><span class="p">:</span>
                    <span class="n">too_many_patterns</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">too_many_patterns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TRUNCATE_IF_TOO_BIG</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: too much note data, truncated patterns&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChiptuneSAKContentError</span><span class="p">(</span><span class="s2">&quot;Error: More than </span><span class="si">%d</span><span class="s2"> goattracker patterns created&quot;</span>
                                              <span class="o">%</span> <span class="n">GT_MAX_PATTERNS_PER_SONG</span><span class="p">)</span>

    <span class="c1"># Usually, songs repeat.  Each channel&#39;s orderlist ends with RST00, which means restart at the</span>
    <span class="c1"># 1st entry in that channel&#39;s pattern list (note: orderlist is normally full of pattern numbers,</span>
    <span class="c1"># but the number after RST is not a pattern number, but an index back into that channel&#39;s orderlist)</span>
    <span class="c1"># As far as I can tell, people create an infinite loop at the end when they don&#39;t want a song to</span>
    <span class="c1"># repeat, so that&#39;s what this code can do.</span>

    <span class="c1"># end_with_repeat == False in no way implies that all tracks will restart at the same time...</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">end_with_repeat</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">too_many_patterns</span><span class="p">:</span>
        <span class="c1"># create a new empty pattern for all channels to loop on forever</span>
        <span class="c1"># and add to the end of each orderlist</span>
        <span class="n">loop_pattern</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="n">loop_pattern</span> <span class="o">+=</span> <span class="n">GtPatternRow</span><span class="p">(</span><span class="n">note_data</span><span class="o">=</span><span class="n">GT_KEY_OFF</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
        <span class="n">loop_pattern</span> <span class="o">+=</span> <span class="n">PATTERN_END_ROW</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
        <span class="n">patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_pattern</span><span class="p">)</span>
        <span class="n">loop_pattern_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_pattern_num</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
        <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GT_OL_RST</span><span class="p">)</span>  <span class="c1"># patterns end with restart indicator</span>
        <span class="k">if</span> <span class="n">end_with_repeat</span><span class="p">:</span>
            <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># index of start of channel order list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># index of the empty loop pattern</span>

    <span class="n">gt_binary</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>

    <span class="c1"># append headers to gt binary</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">GT_FILE_HEADER</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">pad_or_truncate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">pad_or_truncate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">composer</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">pad_or_truncate</span><span class="p">(</span><span class="n">rchirp_song</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copyright</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mh">0x01</span><span class="p">)</span>  <span class="c1"># number of subtunes</span>

    <span class="c1"># append orderlists to gt binary</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
        <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># orderlist length minus 1</span>
        <span class="n">gt_binary</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">orderlists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># append instruments</span>
    <span class="c1"># FUTURE: At some point, should add support for loading gt .ins instrument files for the channels</span>
    <span class="c1"># Need an instrument</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        waveform</span>
<span class="sd">    </span>
<span class="sd">            0 = triangle          10</span>
<span class="sd">            1 = sawtooth          20</span>
<span class="sd">            2 = pulse (square)    40</span>
<span class="sd">            3 = noise             80</span>
<span class="sd">            4 = ring modulation </span>
<span class="sd">    </span>
<span class="sd">    pw</span>
<span class="sd">        pulse width (0-4095) </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    Envelope                                               Wave-</span>
<span class="sd">    Number    Instrument  Attack  Decay  Sustain  Release  form   Width</span>
<span class="sd">    </span>
<span class="sd">    0         Piano       0       9      0        0        2      x600</span>
<span class="sd">    1         Accordion   C       0      C        0        1</span>
<span class="sd">    2         Calliope    0       0      F        0        0</span>
<span class="sd">    3         Drum        0       5      5        0        3</span>
<span class="sd">    4         Flute       9       4      4        0        0</span>
<span class="sd">    5         Guitar      0       9      2        1        1</span>
<span class="sd">    6         Harpsicord  0       9      0        0        2      x200</span>
<span class="sd">    7         Organ       0       9      9        0        2      x800</span>
<span class="sd">    8         Trumpet     8       9      4        1        2      x200</span>
<span class="sd">    9         Xylophone   0       9      0        0        0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># For now, we have 13 instruments available: the C128 BASIC instruments, a simple triangle,</span>
    <span class="c1"># a simple sawtooth, and a simple pulse</span>
    <span class="n">instruments</span> <span class="o">=</span> <span class="p">[</span><span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Piano&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0xC0</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0xC0</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x03</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Accordion&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0xF0</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x05</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Calliope&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x05</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x07</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Drum&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x94</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Flute&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x21</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x0B</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Guitar&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x0D</span><span class="p">,</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Harpsichord&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x30</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x0F</span><span class="p">,</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Organ&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x89</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x41</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x11</span><span class="p">,</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Trumpet&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x09</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x13</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;C128 Xylophone&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x22</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0xFA</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x15</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;Simple Triangle&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x23</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x4F</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x17</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;Simple Sawtooth&#39;</span><span class="p">),</span>
                   <span class="n">GtInstrument</span><span class="p">(</span><span class="n">instr_num</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span>
                                <span class="n">attack_decay</span><span class="o">=</span><span class="mh">0x22</span><span class="p">,</span> <span class="n">sustain_release</span><span class="o">=</span><span class="mh">0x4F</span><span class="p">,</span> <span class="n">wave_ptr</span><span class="o">=</span><span class="mh">0x19</span><span class="p">,</span> <span class="n">pulse_ptr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">inst_name</span><span class="o">=</span><span class="s1">&#39;Simple Pulse&#39;</span><span class="p">),</span>
                   <span class="p">]</span>
    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instruments</span><span class="p">))</span>  <span class="c1"># number of instruments (not counting NOP instrument 0)</span>
    <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">instruments</span><span class="p">:</span>
        <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">instrument_to_bytes</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>

    <span class="c1"># append tables</span>
    <span class="c1"># TODO: Currently hardcoded</span>
    <span class="n">wavetable</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Piano</span>
                 <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Accordion</span>
                 <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Calliope</span>
                 <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Drum</span>
                 <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Flute</span>
                 <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Guitar</span>
                 <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Harpsichord</span>
                 <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Organ</span>
                 <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Trumpet</span>
                 <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Xylophone</span>
                 <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Simple Triangle</span>
                 <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Simple Sawtooth</span>
                 <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># Simple 50% pulse</span>
                 <span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">wavetable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavetable</span><span class="p">),</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">wavetable</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavetable</span><span class="p">),</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">left</span>  <span class="c1"># Right column is all zeros</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">right</span>

    <span class="n">pulsetable</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># 50% pulse</span>
                        <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># .375 pulse</span>
                        <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>  <span class="c1"># .125 pulse</span>
                        <span class="p">])</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">pulsetable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pulsetable</span><span class="p">),</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">pulsetable</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pulsetable</span><span class="p">),</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">left</span>  <span class="c1"># Right column is all zeros</span>
    <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">right</span>

    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span>  <span class="c1"># length 0 filtertable</span>

    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span>  <span class="c1"># length 0 speedtable</span>

    <span class="c1"># append patterns</span>
    <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">))</span>  <span class="c1"># number of patterns</span>
    <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error: unexpected pattern byte length&quot;</span>
        <span class="n">gt_binary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># length of pattern in rows</span>
        <span class="n">gt_binary</span> <span class="o">+=</span> <span class="n">pattern</span>

    <span class="k">return</span> <span class="n">gt_binary</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">ChiptuneSAK</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MusicConcepts.html">Musical Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html">Chirp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html#chirp-formats">Chirp Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chirp.html#concepts-in-chirp-music-representation">Concepts in chirp music representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sheetmusic.html">PDF Sheetmusic via Lilypond</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c128BASIC.html">C128 BASIC music programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Classes.html">Classes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, David Youd and David Knapp.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>